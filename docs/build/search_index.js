var documenterSearchIndex = {"docs":
[{"location":"ch4_sec2_benchmark.html#Benchmark-Testing-1","page":"Benchmark Testing","title":"Benchmark Testing","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#Code-Loading-1","page":"Code Loading","title":"Code Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The current confusion is on how Julia load packages and modules that are not registered through Pkg.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Working-Directory-1","page":"Code Loading","title":"Working Directory","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The working directory, which can be obtained by pwd(), has to be the one containing our packages for things to be loaded correctly.\nWe can add the command cd(@__DIR__) at the beginning of our code to navigate the directory to where our code is running.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Package-Loading-1","page":"Code Loading","title":"Package Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Assmue we would like to use our developed but unregistered package EGRIP.jl at a Julia file named testrun.jl. There are two ways to load EGRIP.jl.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Include-the-package-and-corresponding-modules-1","page":"Code Loading","title":"Include the package and corresponding modules","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can include the main jl file of the package at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory containing `testrun.jl`\ninclude(\"path to the source code from current working directory/src/EGRIP.jl\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through relative path import of the main module since it cannot be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using .EGRIP # It tells Julia to find the module around the current working directory instead of Julia Environment","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Due to the similar reason, other modules in the package cannot be identified by Julia Environment. When module_a in file_module_a.jl needs to use a function fun_b from module_b in file_module_b.jl, we need to do the following at the beginning of file_module_a.jl (assmue file_module_a.jl and file_module_b.jl are in the same directory):","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"include(\"file_module_b.jl\")\nusing .module_b","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, if fun_b has been exported, we can directly access it. Otherwise. we need to use module_b.fun_b. This is not very convenient.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Add-source-code-directory-into-Julia-Environment-1","page":"Code Loading","title":"Add source code directory into Julia Environment","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can make source directory accessible through Julia's LOAD_PATH. We can add the following line at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory `testrun.jl`\npush!(LOAD_PATH,\"path to the source code from current working directory/src/\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through absolute path import of the main module since it can be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using EGRIP # It tells Julia to find the module in Julia Environment LOAD_PATH","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"In addition, all other modules can be used in the same way.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Discussion-on-include-1","page":"Code Loading","title":"Discussion on include","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia’s include is a function, not a simple input redirector (as in C, Fortran, or Matlab).\nEvaluate the contents of a source file in the current context. “The current context” means the global scope of the current module when the evaluation takes place.\nThis function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\nInclude works in the dynamically-current module, not the lexically-current one.\nIt is really a load-time function, not a run-time one.","category":"page"},{"location":"ch1_sec1_install.html#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"For now since EGRIP.jl has not been registered, we need to load the package locally by putting the following code at the beginning of your test script:","category":"page"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")","category":"page"},{"location":"ch2_sec2_library_internal.html#Internal-Library-1","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#Formulation-Function-1","page":"Internal Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"bs_initial_step.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_branch-NTuple{9,Any}","page":"Internal Library","title":"EGRIP.form_branch","text":"branch (power flow) constraints\n\nlinearized power flow\n\nbeginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_bs_logic-NTuple{8,Any}","page":"Internal Library","title":"EGRIP.form_bs_logic","text":"generator cranking constraint\n\nThis part is the key feature of black start. The logic is as follows:\nOnce a non-black start generator is on, that is, y[g]=1, then it needs to absorb the cranking power for its corresponding cranking time\n\"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator\nset non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power\nMathematically if there exist enough 1 for y[g], then enable this generator's generating capability\nThere will be the following scenarios\n(1) generator is off, then y[g,t] - y[g,t-Tcr[g]] = 0, then pg[g,t] == 0\n(2) generator is on but cranking time not satisfied, then y[g,t] - y[g,t-Tcr[g]] = 1, then pg[g,t] == -Pcr[g]\n(3) generator is on and just satisfies the cranking time, then y[g,t] - y[g,t-Tcr[g]] = 0, y[g,t-Tcr[g]-1]=0, then pg[g,t] == 0\n(4) generator is on and bigger than satisfies the cranking time, then y[g,t] - y[g,t-Tcr[g]] = 0, y[g,t-Tcr[g]-1]=1, then 0 <= pg[g,t] <= pg_max\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_logic-NTuple{8,Any}","page":"Internal Library","title":"EGRIP.form_gen_logic","text":"generator status and output constraint\n\ngenerator ramping rate constraint\nblack-start unit is determined by the cranking power\non-line generators cannot be shut down\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_load_logic","text":"load pickup constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_nodal-NTuple{17,Any}","page":"Internal Library","title":"EGRIP.form_nodal","text":"form the nodal constraints:\n\nvoltage constraint\nvoltage constraints are only activated if the associated line is energized\nIf x=0, vlij=0, vlij >= vi - vimax, vlij <= vi - vimin\nIf x=1, vl=0, vl >= v - v_max\nvoltage deviation should be limited\nangle difference constraint\nangle difference constraints are only activated if the associated line is energized\nangle difference should be limited\ngenerator and bus energizing logics\non-line generator cannot be shut down\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#I/O-Function-1","page":"Internal Library","title":"I/O Function","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"parser.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP._check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP._check_conductors","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._check_cost_function-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP._check_cost_function","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._make_mixed_units-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_mixed_units","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._make_per_unit-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_per_unit","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._rescale_cost_model-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._rescale_cost_model","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._simplify_pwl_cost","page":"Internal Library","title":"EGRIP._simplify_pwl_cost","text":"checks the slope of each segment in a pwl function, simplifies the function if the slope changes is below a tolerance\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec2_library_internal.html#EGRIP.add_dcline_costs-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.add_dcline_costs","text":"adds dcline costs, if gen costs exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.add_line_delimiter-Tuple{AbstractString,Any,Any}","page":"Internal Library","title":"EGRIP.add_line_delimiter","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.apply_func-Tuple{Dict{String,Any},String,Any}","page":"Internal Library","title":"EGRIP.apply_func","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.arrays_to_dicts!-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.arrays_to_dicts!","text":"turns top level arrays into dicts\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_branch_directions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_directions","text":"checks that all parallel branches have the same orientation\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_branch_loops-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_loops","text":"checks that all branches connect two distinct buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_bus_types-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_bus_types","text":"checks bus types are consistent with generator connections, if not, fixes them\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_conductors","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_connectivity-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_connectivity","text":"checks that all buses are unique and other components link to valid buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_cost_functions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_cost_functions","text":"throws warnings if cost functions are malformed\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_current_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_current_limits","text":"checks that each branch has a reasonable current rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_dcline_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_dcline_limits","text":"checks that parameters for dc lines are reasonable\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_keys-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_keys","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_network_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_network_data","text":"Runs various data quality checks on a PowerModels data dictionary. Applies modifications in some cases.  Reports modified component ids.\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_storage_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_storage_parameters","text":"checks that each storage unit has a reasonable parameters\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_thermal_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_thermal_limits","text":"checks that each branch has a reasonable thermal rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_transformer_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_transformer_parameters","text":"checks that each branch has a reasonable transformer parameters this is important because setting tap == 0.0 leads to NaN computations, which are hard to debug\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_type-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_type","text":"Checks if the given value is of a given type, if not tries to make it that type\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_voltage_angle_differences","page":"Internal Library","title":"EGRIP.check_voltage_angle_differences","text":"checks that voltage angle differences are within 90 deg., if not tightens\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_voltage_setpoints-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_voltage_setpoints","text":"throws warnings if generator and dc line voltage setpoints are not consistent with the bus voltage setpoint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.make_mixed_units-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_mixed_units","text":"Transforms network data into mixed-units (inverse of per-unit)\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.make_per_unit-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_per_unit","text":"Transforms network data into per-unit\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.matpower_to_powermodels-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.matpower_to_powermodels","text":"Converts a Matpower dict into a PowerModels dict\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_bus_name_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_bus_name_data","text":"merges bus name data into buses, if names exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_generator_cost_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generator_cost_data","text":"merges generator cost functions into generator data, if costs exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_generic_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generic_data","text":"merges Matpower tables based on the table extension syntax\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp2pm_branch-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_branch","text":"sets all branch transformer taps to 1.0, to simplify branch models\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp2pm_dcline-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_dcline","text":"adds pmin and pmax values at to and from buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp_cost_data-Tuple{Any}","page":"Internal Library","title":"EGRIP.mp_cost_data","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_cells-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_cells","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_data-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_data","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_matrix-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_matrix","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_file-Tuple{IO}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_file-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_string-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_string","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_mfile-Tuple{Union{IO, String}}","page":"Internal Library","title":"EGRIP.parse_mfile","text":"Parses the matpower data from either a filename or an IO object\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.row_to_dict-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.row_to_dict","text":"takes a row from a matrix and assigns the values names\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.simplify_cost_terms-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.simplify_cost_terms","text":"trims zeros from higher order cost terms\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.split_line-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.split_line","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.split_loads_shunts-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.split_loads_shunts","text":"splitloadsshunts(data) Seperates Loads and Shunts in data under separate \"load\" and \"shunt\" keys in the PowerModels data format. Includes references to originating bus via \"loadbus\" and \"shuntbus\" keys, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.type_array-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Internal Library","title":"EGRIP.type_array","text":"Attempts to determine the type of an array of strings extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.type_value-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.type_value","text":"Attempts to determine the type of a string extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"ch3_sec3_dev_package_org.html#Package-Organization-1","page":"Package Organization","title":"Package Organization","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#Option-1-1","page":"Package Organization","title":"Option 1","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We could build one main module called EGRIP and several submodules.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In this way, we will declare certain submodule to access its function in another module once the source code is loaded into LOAD_PATH.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"For example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"Then, in a testing script, we can use the package by","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using EGRIP\nfun_bs()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In addition, we can use the module independently from EGRIP","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using PowerFlow\nfun_pf()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"A different but not good way to do include file.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"This is suggested to do the include in the main module. And once it is loaded to LOAD_PATH, every included script is accessible.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\ninclude(\"power_flow.jl\")\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#Option-2-1","page":"Package Organization","title":"Option 2","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We just build one main module EGRIP. The rest functionalities are implemented by functions in different scripts. Then, we just need to include the scripts in the main module. Once the main module is loaded into LOAD_PATH, we can these functions freely between different scripts without further declaration. Some Julia packages like PowerModels.jl are organized in this way. Take an example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_pf()\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_lr()\n  func_pf()\nend","category":"page"},{"location":"ch2_sec1_library_public.html#Public-Library-1","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#Formulation-Function-1","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#","page":"Public Library","title":"Public Library","text":"use @docs block to splice the docstrings","category":"page"},{"location":"ch2_sec1_library_public.html#","page":"Public Library","title":"Public Library","text":"solve_restoration","category":"page"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration","page":"Public Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch1_sec4_workflow.html#Restoration-Planning-and-Verification-Workflow-1","page":"Restoration Workflow","title":"Restoration Planning and Verification Workflow","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Integrated restoration optimization model produces an initial parallel recovery plan\nCranking path module finds transmission path to energize to crank a generator\nTransient stability and static security constraints are validated by simulation\nThree options to fix a restoration plan\nAdd compensation devices\nSwitch to another cranking path\nRe-optimize startup sequences\nIf a restoration plan cannot be repaired (or sacrifice too much solution quality), remove current plan from solution space and resolve the integrated restoration optimization model","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"(Image: Restoration workflow)","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Planning-1","page":"Restoration Workflow","title":"Restoration Planning","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"We can use the package by declaring it:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"using EGRIP","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"First, we need to tell the package where our problem data is:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_network = \"./case39.m\"\ndir_case_blackstart = \"./BS_generator.csv\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Second, we need to tell the package where our results are going to be stored:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_result = \"./results/\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Then, we define the restoration duration and time steps:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"t_final = 500\nt_step = 250","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once everything is ready, we can call solve_restoration function to solve the problem:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"solve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Part of the results will be printed once the algorithm terminates.","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Line energization:\nstage 1.0:\nstage 2.0:\n\nGenerator energization:\nstage 1.0: 39\nstage 2.0:\n\nBus energization:\nstage 1.0: 39\nstage 2.0:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Detailed results will be stored in results folder under the directory containing the case file.","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Verification-1","page":"Restoration Workflow","title":"Restoration Plan Verification","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"This process consists of two steps. The first step is to generate restoration plan file (an event list) using the function generateRestorationPlanFromOpt. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"optResPath: The path containing the optimized restoration plan result\noutFileName: the name of the restoration plan file to be generated\ndataFile: The name of the associated system data file (PSAT format, .m)\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function will output exitflag, which 1 means success and fail otherwise. The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"generateRestorationPlanFromOpt('D:\\Box Sync\\Blackstart_data\\Blackstart_data\\','restoration_plan_test_039.m','d_datane_39_mod_PQ_3')","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the event list is generated, we can run the simulation using the function runDynamicSimulation. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dataFile: The name of the associated system data file (PSAT format, .m)\nrestSettingFile: the name of the restoration plan file\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"There will be two outpus:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"exitflag=1: run the whole simulation, otherwise: DSA did not finish all the simulation\nmsg: detailed message","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"[flag,msg]=runDynamicSimulation('d_datane_39_mod_PQ_3','restoration_plan_test_039')","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the simulation is completed, we could load the simulation data:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Load the *_simp.mat result file (located in ./restoration/)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"and plot the results:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"plotCurves(1,t,stateCurve,SysDataBase,’variableName’)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The results of the IEEE 39-bus system are shown below. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch4_sec1_literature.html#Literature-Review-1","page":"Literature Review","title":"Literature Review","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#Mathematical-Model-1","page":"Problem Formulations","title":"Mathematical Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"As PowerModels implements a variety of power network optimization problems, the implementation is the best reference for precise mathematical formulations.  This section provides a complex number based mathematical specification for a prototypical AC Optimal Power Flow problem, to provide an overview of the typical mathematical models in PowerModels.","category":"page"},{"location":"ch1_sec2_formulations.html#Sets-and-Parameters-1","page":"Problem Formulations","title":"Sets and Parameters","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower.  These generalizations make it possible for PowerModels to more accurately capture industrial transmission network datasets.  The core generalizations are,","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Support for multiple load (S^d_k) and shunt (Y^s_k) components on each bus i\nLine charging that supports a conductance and asymmetrical values (Y^c_ij Y^c_ji)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign","category":"page"},{"location":"ch1_sec2_formulations.html#AC-Optimal-Power-Flow-1","page":"Problem Formulations","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"A complete mathematical model is as follows,","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G mbox - generator complex power dispatch labelvar_generation\n V_i  forall iin N labelvar_voltage mbox - bus complex voltage\n S_ij  forall (ij) in E cup E^R  labelvar_complex_power mbox - branch complex power flow\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k labeleq_objective\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R labeleq_ref_bus\n S^gl_k leq S^g_k leq S^gu_k  forall k in G  labeleq_gen_bounds\n v^l_i leq V_i leq v^u_i  forall i in N labeleq_voltage_bounds\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N labeleq_kcl_shunt \n S_ij = left( Y_ij + Y^c_ijright)^* fracV_i^2T_ij^2 - Y^*_ij fracV_i V^*_jT_ij  forall (ij)in E labeleq_power_from\n S_ji = left( Y_ij + Y^c_ji right)^* V_j^2 - Y^*_ij fracV^*_i V_jT^*_ij  forall (ij)in E labeleq_power_to\n S_ij leq s^u_ij  forall (ij) in E cup E^R labeleq_thermal_limit\n I_ij leq i^u_ij  forall (ij) in E cup E^R labeleq_current_limit\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E labeleq_angle_difference\n\nendalign","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Note that for clarity of this presentation some model variants that PowerModels supports have been omitted (e.g. piecewise linear cost functions and HVDC lines).  Details about these variants is available in the Matpower documentation.","category":"page"},{"location":"ch1_sec2_formulations.html#Mapping-to-function-names-1","page":"Problem Formulations","title":"Mapping to function names","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Eq. eqrefvar_generation - variablegenpower\nEq. eqrefvar_voltage - variablebusvoltage\nEq. eqrefvar_complex_power - variablebranchpower\nEq. eqrefeq_objective -\nEq. eqrefeq_ref_bus -\nEq. eqrefeq_gen_bounds -\nEq. eqrefeq_voltage_bounds -\nEq. eqrefeq_kcl_shunt -\nEq. eqrefeq_power_from -\nEq. eqrefeq_power_to -\nEq. eqrefeq_thermal_limit -\nEq. eqrefeq_current_limit -\nEq. eqrefeq_angle_difference -","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Advanced-Algorithms-1","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#Multi-Resolution-Approach-1","page":"Advanced Algorithms","title":"Multi-Resolution Approach","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We developed a multi-resolution restoration algorithm to accelerate the overall solution time and prepare the software package for large-scale systems. The approach is based on the fact that better solutions can be found with smaller time steps, that is, higher resolution, which results in more complex optimization model. In addition, it is often difficult for the solver to obtain a feasible solution when the time step is small. Therefore, the essence of the algorithm is to hierarchically increase the resolution (that is, decrease the time steps) and guide the search of higher-resolution problem using solutions from lower-resolution solutions. Specifically, generator decision variables at certain time interval will be fixed to either zero or one depending on the result from the previous step. The algorithm is illustrated in Figure 1, where Figure 1 (a) shows the step of the approach and Figure 1 (b) illustrate the fixing rules. (Image: Multi-resolution method)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We verify the method on the black start problem for the IEEE 39-bus system. The computation results are shown in Table 1. In Scenario 3, the solver cannot reach to convergence after 7000 seconds. On the other hand, the proposed method can save 40% of the computation time without loss of optimality. This preliminary computation experiments verify the effectiveness of our proposed approach. (Image: Multi-resolution results)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Enhanced-Extended-Term-Event-Driven-Simulation-1","page":"Advanced Algorithms","title":"Enhanced Extended-Term Event-Driven Simulation","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We enhanced the extended-term simulation approach based on semi-analytical simulation (SAS) for restoration studies. And we implemented hybrid simulation switching between the full-dynamic simulation and quasi-steady-state (QSS) simulation. The switch from full-dynamic simulation to QSS simulation is realized directly from SAS coefficients, which is much more efficient than the traditional method that needs extra period of simulation. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We further use SAS to simulate a restoration process of IEEE 39-bus system. The whole process lasts 12,065s and includes 396 events, including bus energization, line energization, line switching, generator cut-in, generator ramping, load cut-in, load ramping events. The QSS simulation covers about 39% of the whole process, and the time saving compared with full-dynamic simulation is about 36%. This verifies that QSS simulation is much faster than the full-dynamic simulation, and the hybrid simulation can significantly enhance efficiency without losing accuracy. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch3_sec1_development_overview.html#Development-Overview-1","page":"Development Overview","title":"Development Overview","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Directory-Tree-1","page":"Development Overview","title":"Directory Tree","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Dependency-1","page":"Development Overview","title":"Dependency","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Documentation-Notes-1","page":"Development Overview","title":"Documentation Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"We use Documenter.jl.","category":"page"},{"location":"ch3_sec1_development_overview.html#Other-Detailed-Notes-1","page":"Development Overview","title":"Other Detailed Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"Code Loading\nPackage Organization","category":"page"},{"location":"index.html#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Welcome to the documentation for EGRIP.jl!","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"EGRIP.jl (Electricity Grid Resilience Improvement Program) is a Julia/MATALB package for power system restoration planning and verification. The objective of this toolkit is to:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Improve the preparedness of power systems for extreme weather conditions\nEnhance the capability of quick recovery from damages (such as partial or complete blackout)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The holistic framework shown below consists of three main modules: nowcasting weather forecasting, simulation and restoration.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simulation module provides predictive outages and damages, and dynamic security assessment for restoration plan to guarantee practicality\nRestoration module provides Multi-time scale (resource allocation and operation) multi-level (bulk power system and distribution level) restoration optimization","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Holistic structure)","category":"page"},{"location":"index.html#Optimization-Core-1","page":"Home","title":"Optimization Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The optimization core is designed in a modularize and hierarchical manner to facilitate future algorithm development, multi-purpose usage as well as reduce the coding overhead. It consists of three levels, that is, fundamental function level, ordinary problem level and advanced solution level.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The fundamental function level is to provide basic optimization formulations. Currently it consists of generator dispatch model, generator cranking model, controllable load dispatch model, linearized AC power flow model and AC power flow model as well as data I/O.\nThe ordinary problem level formulates different problems using appropriate functions from both fundamental and its own levels. Currently there are three ordinary problems, that is, load restoration problem, system black-start problem and AC power flow feasibility checking problem. The load restoration problem is to a single-stage optimization to maximize served load under a fixed topology. The system black-start problem is built based on the load restoration problem to provide multi-stage restoration plans.\nThe advanced solution level is to either speed up the computation or accommodate new capabilities using both state-of-the-art optimization algorithm and power system domain knowledge. Currently it consists of the multi-resolution restoration algorithm and meta heuristic enhancement. The multi-resolution restoration algorithm is to accelerate the overall solution time by guiding the search of higher-resolution problem using solutions from lower-resolution solutions. The meta heuristic enhancement uses power system domain knowledge and to add additional physical constraints and empirical rules to speed up the computation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Simulation-Core-1","page":"Home","title":"Simulation Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The simulation core is used for the resilience assessment of system under possible extreme events and in the restoration process. The simulation core utilizes the simulation tool based on semi-analytical solutions (SAS). The SAS has enhanced numerical robustness and computational efficiency, which enables the analysis of very complex dynamic processes in large-scale power systems. The SAS-based simulation tool has the following major features:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Flexible customization of event sequences. Users can conveniently define the event sequences through an event list file. The simulation tool supports various types of events, such as adding/tripping components, adding/clearing faults, ramping of load/ generation. The event scheduler dispatches the simulation workflow to simulate the event sequence.\nRich model library. The simulation tool supports steady-state analysis and dynamic simulation. The model library includes dynamic models of synchronous generators, controllers (AVR and turbine governor), static load (e.g. ZIP) and induction motor load, and AGC model. And the model library is still expanding. The simulation tool admits widely supported PSAT data format.\nEnhanced robustness. The SAS as a high-order advanced computational approach with analytical form, has guaranteed numerical convergence to existing solution. Therefore, the SAS users are worry-free of non-convergence issues, and the simulation tool has good capability of performing very complex power system resilience analysis tasks.\nEnhanced efficiency with steady-state & dynamic hybrid simulation. The simulator automatically switches between full-dynamic simulation (where fast transients are significant) and quasi-steady-state (QSS) simulation (where the transients decay and approximately enters steady-state). The hybrid simulation scheme significantly saves computation time compared with the full-dynamic simulation, typically by 30%-70% depending on studied cases.\nFriendly output and visualization functions. The SAS-based simulation tool has a log system that enables printing and recording different levels of events in simulation. After simulation, users can conveniently plot the trajectories of various system states through a specially designed plotting function.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Installation\nMathematical Model\nAdvanced Algorithms\nRestoration Planning and Verification Workflow","category":"page"},{"location":"index.html#Library-1","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Public Library\nInternal Library","category":"page"},{"location":"index.html#Developer-1","page":"Home","title":"Developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Development Overview\nCode Loading\nPackage Organization","category":"page"},{"location":"index.html#Research-1","page":"Home","title":"Research","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Literature Review\nBenchmark Testing","category":"page"}]
}
