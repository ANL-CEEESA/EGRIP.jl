var documenterSearchIndex = {"docs":
[{"location":"ch4_sec2_benchmark.html#Benchmark-Testing","page":"Benchmark Testing","title":"Benchmark Testing","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#Code-Loading","page":"Code Loading","title":"Code Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"The current confusion is on how Julia load packages and modules that are not registered through Pkg.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Working-Directory","page":"Code Loading","title":"Working Directory","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"The working directory, which can be obtained by pwd(), has to be the one containing our packages for things to be loaded correctly.\nWe can add the command cd(@__DIR__) at the beginning of our code to navigate the directory to where our code is running.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Package-Loading","page":"Code Loading","title":"Package Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Assmue we would like to use our developed but unregistered package EGRIP.jl at a Julia file named testrun.jl. There are two ways to load EGRIP.jl.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Include-the-package-and-corresponding-modules","page":"Code Loading","title":"Include the package and corresponding modules","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"We can include the main jl file of the package at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory containing `testrun.jl`\ninclude(\"path to the source code from current working directory/src/EGRIP.jl\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through relative path import of the main module since it cannot be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"using .EGRIP # It tells Julia to find the module around the current working directory instead of Julia Environment","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Due to the similar reason, other modules in the package cannot be identified by Julia Environment. When module_a in file_module_a.jl needs to use a function fun_b from module_b in file_module_b.jl, we need to do the following at the beginning of file_module_a.jl (assmue file_module_a.jl and file_module_b.jl are in the same directory):","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"include(\"file_module_b.jl\")\nusing .module_b","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Then, if fun_b has been exported, we can directly access it. Otherwise. we need to use module_b.fun_b. This is not very convenient.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Add-source-code-directory-into-Julia-Environment","page":"Code Loading","title":"Add source code directory into Julia Environment","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"We can make source directory accessible through Julia's LOAD_PATH. We can add the following line at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory `testrun.jl`\npush!(LOAD_PATH,\"path to the source code from current working directory/src/\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through absolute path import of the main module since it can be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"using EGRIP # It tells Julia to find the module in Julia Environment LOAD_PATH","category":"page"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"In addition, all other modules can be used in the same way.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Discussion-on-include","page":"Code Loading","title":"Discussion on include","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html","page":"Code Loading","title":"Code Loading","text":"Julia’s include is a function, not a simple input redirector (as in C, Fortran, or Matlab).\nEvaluate the contents of a source file in the current context. “The current context” means the global scope of the current module when the evaluation takes place.\nThis function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\nInclude works in the dynamically-current module, not the lexically-current one.\nIt is really a load-time function, not a run-time one.","category":"page"},{"location":"ch1_sec1_install.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"ch1_sec1_install.html","page":"Installation","title":"Installation","text":"For now since EGRIP.jl has not been registered, we need to load the package locally by putting the following code at the beginning of your test script:","category":"page"},{"location":"ch1_sec1_install.html","page":"Installation","title":"Installation","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")","category":"page"},{"location":"ch1_sec2_tutorials.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Integrated restoration optimization model produces an initial parallel recovery plan\nCranking path module finds transmission path to energize to crank a generator\nTransient stability and static security constraints are validated by simulation\nThree options to fix a restoration plan\nAdd compensation devices\nSwitch to another cranking path\nRe-optimize startup sequences\nIf a restoration plan cannot be repaired (or sacrifice too much solution quality), remove current plan from solution space and resolve the integrated restoration optimization model","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"(Image: Restoration workflow)","category":"page"},{"location":"ch1_sec2_tutorials.html#Restoration-Plan-Optimization","page":"Tutorials","title":"Restoration Plan Optimization","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html#Interactive-Usage","page":"Tutorials","title":"Interactive Usage","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"We can load and use the package using:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"First, we need to tell the package where our problem data is. Assume the data is at the same directory of the executing script, then the data can be loaded as:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"dir_case_network = \"case39.m\"\ndir_case_blackstart = \"BS_generator.csv\"","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Second, we need to tell the package where our results are going to be stored. Let's save the results in a child folder results:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"dir_case_result = \"results/\"","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Then, we define the restoration duration and time steps:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"t_final = 300\nt_step = 100","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"At last, we set the gap for the solver:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"gap = 0.15","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Once everything is ready, we can call solve_restoration function to solve the problem:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"solve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Part of the results will be printed once the algorithm terminates.","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Line energization:\nstage 1.0:\nstage 2.0:\nstage 3.0: (8,9) (25,37) (16,17) (20,34) (22,23) (19,20) (22,35) (6,11) (9,39) (13,14) (5,8) (19,33) (26,27) (14,15) (12,13) (10,13) (15,16) (16,24) (12,11) (29,38) (16,19) (23,36) (6,31) (26,29) (23,24) (5,6) (4,14) (17,27) (25,26)\n\nGenerator energization:\nstage 1.0: 39\nstage 2.0:\nstage 3.0: 36 33 38 31 37 34 35\n\nBus energization:\nstage 1.0: 12 1 11 39 19 20 13\nstage 2.0: 18 16 5\nstage 3.0: 2 21 7 26 25 35 34 29 10 9 17 8 22 6 24 4 37 28 38 23 31 14 27 36 15 33","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Detailed results will be stored in results folder under the directory containing the case file.","category":"page"},{"location":"ch1_sec2_tutorials.html#Command-Line-Usage","page":"Tutorials","title":"Command Line Usage","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Alternatively, we can build a command-line tool. First, we create a script file named solve_bs.jl and write the following Julia code in the script:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP\ndir_case_network = ARGS[1]\ndir_case_blackstart = ARGS[2]\ndir_case_result = ARGS[3]\nt_final = parse(Int64, ARGS[4])\nt_step = parse(Int64, ARGS[5])\ngap = parse(Float64, ARGS[6])\nsolve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Open Terminal and navigate to the directory containing solve_bs.jl.","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"$ cd /path to solve_bs/","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Execute the following command:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"$ julia solve_bs.jl 'case39.m' 'BS_generator.csv' 'results/' 300 100 0.15","category":"page"},{"location":"ch1_sec2_tutorials.html#Restoration-Plan-Verification","page":"Tutorials","title":"Restoration Plan Verification","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html#Restoration-Plan-File-Generation","page":"Tutorials","title":"Restoration Plan File Generation","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"This process consists of two steps. The first step is to generate restoration plan file (an event list) using the function generateRestorationPlanFromOpt. We need the following inputs:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"optResPath: The path containing the optimized restoration plan result\noutFileName: the name of the restoration plan file to be generated\ndataFile: The name of the associated system data file (PSAT format, .m)\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"The function will output exitflag, which 1 means success and fail otherwise. The function can be called using the following command:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"generateRestorationPlanFromOpt('D:\\Box Sync\\Blackstart_data\\Blackstart_data\\','restoration_plan_test_039.m','d_datane_39_mod_PQ_3')","category":"page"},{"location":"ch1_sec2_tutorials.html#Simulation","page":"Tutorials","title":"Simulation","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Once the event list is generated, we can run the simulation using the function runDynamicSimulation. We need the following inputs:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"dataFile: The name of the associated system data file (PSAT format, .m)\nrestSettingFile: the name of the restoration plan file\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"There will be two outpus:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"exitflag=1: run the whole simulation, otherwise: DSA did not finish all the simulation\nmsg: detailed message","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"The function can be called using the following command:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"[flag,msg]=runDynamicSimulation('d_datane_39_mod_PQ_3','restoration_plan_test_039')","category":"page"},{"location":"ch1_sec2_tutorials.html#Plots","page":"Tutorials","title":"Plots","text":"","category":"section"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Once the simulation is completed, we could load the simulation data:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"Load the *_simp.mat result file (located in ./restoration/)","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"and plot the results:","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"plotCurves(1,t,stateCurve,SysDataBase,’variableName’)","category":"page"},{"location":"ch1_sec2_tutorials.html","page":"Tutorials","title":"Tutorials","text":"The results of the IEEE 39-bus system are shown below. (Image: Enhanced Extended-Term Simulation) (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch1_sec4_advanced_algorithm.html#Advanced-Algorithms","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"","category":"section"},{"location":"ch1_sec4_advanced_algorithm.html#Multi-Resolution-Approach","page":"Advanced Algorithms","title":"Multi-Resolution Approach","text":"","category":"section"},{"location":"ch1_sec4_advanced_algorithm.html","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We developed a multi-resolution restoration algorithm to accelerate the overall solution time and prepare the software package for large-scale systems. The approach is based on the fact that better solutions can be found with smaller time steps, that is, higher resolution, which results in more complex optimization model. In addition, it is often difficult for the solver to obtain a feasible solution when the time step is small. Therefore, the essence of the algorithm is to hierarchically increase the resolution (that is, decrease the time steps) and guide the search of higher-resolution problem using solutions from lower-resolution solutions. Specifically, generator decision variables at certain time interval will be fixed to either zero or one depending on the result from the previous step. The algorithm is illustrated in Figure 1, where Figure 1 (a) shows the step of the approach and Figure 1 (b) illustrate the fixing rules. (Image: Multi-resolution method)","category":"page"},{"location":"ch1_sec4_advanced_algorithm.html","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We verify the method on the black start problem for the IEEE 39-bus system. The computation results are shown in Table 1 with total time equal to 300 minutes. In Scenario 2, the solver cannot reach to convergence after 71 hours. On the other hand, the proposed method can save eight times of the computation time with slightly compromised optimality. This preliminary computation experiments verify the effectiveness of our proposed approach.","category":"page"},{"location":"ch1_sec4_advanced_algorithm.html","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"Scenario Index Gap Resolution (min) Solving Time (sec) With Fixed Constraint All generator dispatchable (min)\n1 1% 50 728 No 251\n2 1% 20 255854 (71h) without convergence No \\\n3 10% 20 8709 No 201\n4 5% 20 327 Generator sequence fixed based on S1 221","category":"page"},{"location":"ch1_sec4_advanced_algorithm.html#Enhanced-Extended-Term-Event-Driven-Simulation","page":"Advanced Algorithms","title":"Enhanced Extended-Term Event-Driven Simulation","text":"","category":"section"},{"location":"ch1_sec4_advanced_algorithm.html","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We enhanced the extended-term simulation approach based on semi-analytical simulation (SAS) for restoration studies. And we implemented hybrid simulation switching between the full-dynamic simulation and quasi-steady-state (QSS) simulation. The switch from full-dynamic simulation to QSS simulation is realized directly from SAS coefficients, which is much more efficient than the traditional method that needs extra period of simulation. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch1_sec4_advanced_algorithm.html","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We further use SAS to simulate a restoration process of IEEE 39-bus system. The whole process lasts 12,065s and includes 396 events, including bus energization, line energization, line switching, generator cut-in, generator ramping, load cut-in, load ramping events. The QSS simulation covers about 39% of the whole process, and the time saving compared with full-dynamic simulation is about 36%. This verifies that QSS simulation is much faster than the full-dynamic simulation, and the hybrid simulation can significantly enhance efficiency without losing accuracy. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch2_sec2_library_internal.html#Internal-Library","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#Integrated-Restoration","page":"Internal Library","title":"Integrated Restoration","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"restoration.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration_full-NTuple{7,Any}","page":"Internal Library","title":"EGRIP.solve_restoration_full","text":"Solve full restoration problem (The restoration problem could be partial or full restorations)\n\nFull restoration problem assumes that the entire network is broken down.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration_part-NTuple{7,Any}","page":"Internal Library","title":"EGRIP.solve_restoration_part","text":"Solve partial restoration problem (The restoration problem could be partial or full restorations)\n\nPartial restoration problem assumes that a part of the network is still functioning.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Sectionalization-Models","page":"Internal Library","title":"Sectionalization Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"section.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_section-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.solve_section","text":"Solve sectionalization problem for restoration preparedness\n\nProblem type: The sectionalization problem could assign all buses to certain sections or only critical buses.\nInputs:\nnetwork data directory\nrestoration data directory\nresult storage directory\ngap\nOutput:\nJSON file of network data of each section\nConstraints:\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Generator-Startup-Models","page":"Internal Library","title":"Generator Startup Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"startup.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_startup","page":"Internal Library","title":"EGRIP.solve_startup","text":"Solve generator start-up problem\n\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nformulation types\nspecifications of wind power\nwind activation 0 denotes no wind will support the restoration\nwind activation 1 denotes wind will support the restoration with its distribution as normal\nwind activation 2 denotes wind will support the restoration with time seires wind data\nwind activation 3 denotes wind will support the restoration with real quantile and interpolation (linear, cubic, or spline)\nif wind activation = 3, then real wind power density will be specified in wind_data\nThe followings are the keyword arguments\nwind_data: time series wind data\nsaa_mode: different chance constraints enforcement in sample average approximations\nOutput: Generator start-up sequence\nConstraints:\ngenerato cranking\nload pickup\npower balance\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec2_library_internal.html#Generator-Models","page":"Internal Library","title":"Generator Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"gen.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_gen-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_gen","text":"Define generator variables\n\nThe definitation of variables corresponds to different formulations.\nThe default variable definition is the formulation 4, which is used in the resotoration problem\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking","text":"Generator cranking constraint (formulation 4 in the generator start-up formulation and also used in the restoration)\n\nOnce a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time\n\"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator\nset non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power\nMathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability\nThere will be the following scenarios\n(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g\nAll scenarios can be formulated as follows:\n\nbeginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gt-Tcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking_1-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking_1","text":"Generator cranking constraint (formulation 1)\n\nIn the generator start-up sequence optimization problem, we consider the following cranking procedure\n\nbeginalign*\np_g(x_gt)=begincases\n    0  0le tx_g\n    -c_g  x_gle t  x_g+t_g^c\n    r_g(t-x_g-t_g^c)  x_g+t_g^cleq t  x_g+t_g^c+t_g^r\n    p^mboxmax  x_g+t_g^c+t_g^rleq t leq T\nendcases\nendalign*\n\nWe introduce binary variables y_gt, z_gt, and u_gt to indicate whether generator g is in status of cranking, ramping, or full capacity in time period t, respectively. We introduce binary variable x_gt to indicate whether generator g is started in time period t. The formulations are implemented in function form_gen_cranking_2.\n\nFirst, a NBS generator has no activity before it is started\n\nbeginalign*\nbeginaligned\n\t\t(t-1)(1-x_gt) ge sum_i=1^t-1y_giquadforall gin G tin Tbackslash1\nendaligned\nbeginaligned\n\t(t+t^c_g-1)(1-x_gt) ge sum_i=1^f(t) z_giquadforall gin G tin T\nendaligned\nbeginaligned\n\t(t+t^c_g+t^r_g-1)(1-x_gt) ge sum_i=1^g(t)u_giquadforall gin G tin T\nendaligned\n f(t)=minTt+t^c_g-1g(t)=minTt+t^c_g +t^r_g-1\nendalign*\n\nSecond, once started, a cranking is followed\n\nbeginalign*\nsum_i=t^f(t) y_gige x_gttimesminT-t t^c_gquad forall tin T\nendalign*\n\nThird, once cranking is finished, a ramping is followed\n\nbeginalign*\n\tlabeleq_gen_ramp\nsum_i=t+t^r_g-1^g(t) z_gige x_gttimesminT-t t^r_gquad forall tin T\nendalign*\n\nOnce the generator reaches to its maximum value, it should stay in this status\n\nbeginalign*\n\tlabeleq_gen_max\n\tu_gtgeq u_gt-1quad forall tin Tbackslash1\nendalign*\n\nAdditionally, in each stage each generator will have one status being activated, i.e.,\n\nbeginalign*\n\tlabeleq_gen_one_status\ny_gi + z_gi + u_gileq 1quad forall tin T\nendalign*\n\nAnd there exists only one validated generator start-up moment\n\nbeginalign*\n\tlabeleq_gen_one_start\n\tsum_tin Tx_gt =1quad forall gin G\nendalign*\n\nWe can write the generation output of unit g in time period t as\n\nbeginalign*\n\tlabeleq_gen_power\np_g(t) = -c_gy_gt+ sum_i=1^tz_gir_g\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking_2-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking_2","text":"Generator cranking constraint (formulation 2)\n\nIn the generator start-up sequence optimization problem, we consider the following cranking procedure\n\nbeginalign*\np_g(x_gt)=begincases\n    0  0le tx_g\n    -c_g  x_gle t  x_g+t_g^c\n    r_g(t-x_g-t_g^c)  x_g+t_g^cleq t  x_g+t_g^c+t_g^r\n    p^mboxmax  x_g+t_g^c+t_g^rleq t leq T\nendcases\nendalign*\n\nHere, we can use a scenario-based idea to formulate individual generator's output p_gt at time t. Let x_gtin01 denote if non-black-start generator g is started in time period t.\n\nThe generator's output p_gt can be expressed as follows\n\n    beginalign*\n\tbeginaligned\n\t\tp_gt = sum_i=1^tx_gtp_g(it)forall tin T\n\tendaligned\n    endalign*\n\nNote that p_g(it) is constant given i and t.\n\nThe generator can only be started once, so we have\n\nbeginalign*\n    sum_tin Tp_gt=1\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking_3-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking_3","text":"Generator cranking constraint (formulation 3)\n\nIn the generator start-up sequence optimization problem, we consider the following cranking procedure\n\nbeginalign*\np_g(x_gt)=begincases\n    0  0le tx_g\n    -c_g  x_gle t  x_g+t_g^c\n    r_g(t-x_g-t_g^c)  x_g+t_g^cleq t  x_g+t_g^c+t_g^r\n    p^mboxmax  x_g+t_g^c+t_g^rleq t leq T\nendcases\nendalign*\n\nIf t-x_g0, p_gt=0. Introduce positive large number M and binary variable a_gt. Build t - x_g  0 Leftrightarrow a_gt=1 and t - x_g geq 0 Leftrightarrow a_gt=0, where a_gt=1 indicates generator g is off-line.\n\n        beginalign*\n\t\tbeginaligned\n\t\t\tt - x_gleq M (1- a_gt) \n\t\t\tt-x_g geq -M a_gt \n\t\t\t-M  (1- a_gt) leq p_gt\n\t\t\t p_gtleq M  (1- a_gt)\n\t\tendaligned\n        endalign*\n\nIf x_gle t  and t  x_g+t_g^c, p_gt=-c_g. Introduce positive large number M and binary variable b_gt. Build t  x_g+t_g^c Leftrightarrow b_gt=1 and t geq x_g+t_g^c Leftrightarrow b_gt=0, where b_gt=1 indicates generator g is at the cranking stage.\n\nbeginalign*\n\t\tbeginaligned\n\t\t\tt - x_g- t_g^c leq M (1- b_gt) \n\t\t\tt - x_g- t_g^cgeq -M b_gt \n\t\t\t-M  (1+a_gt- b_gt) leq p_gt + c_g\n\t\t\t p_gt + c_gleq M  (1+a_gt- b_gt)\n\t\tendaligned\n\tendalign*\n\nIf t   x_g+t_g^c+t_g^r, p_gt=r_g(t-x_g-t_g^c). Introduce positive large number M and binary variable c_gt. Build t  x_g+t_g^c+t_g^r Leftrightarrow c_gt=1 and t geq x_g+t_g^c+t_g^r Leftrightarrow c_gt=0, where c_gt=1 indicates generator g is at the ramping stage.\n\nbeginalign*\n\t\tbeginaligned\n\t\t\tt - (x_g+t_g^c+t_g^r) leq M (1- c_gt) \n\t\t\tt - (x_g+t_g^c+t_g^r)geq -M c_gt \n\t\t\t-M  (1+a_gt+ b_gt- c_gt) leq p_gt - r_g(t-x_g-t_g^c)\n\t\t\t p_gt - r_g(t-x_g-t_g^c)leq M  (1+a_gt+ b_gt- c_gt)\n\t\tendaligned\n\tendalign*\n\nFor the last stage, we do not need to introduce new variables.\n\nbeginalign*\n-M  (a_gt+ b_gt + c_gt) leq p_gt - p^mboxmax \n\t\t\t p_gt - p^mboxmax leq M  (a_gt+ b_gt + c_gt)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_logic-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_logic","text":"generator status and output constraint\n\ngenerator ramping rate constraint\n\nbeginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*\n\nblack-start unit is determined by the cranking power\n\nbeginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*\n\non-line generators cannot be shut down\n\nbeginalign*\ny_gt = y_gt+1\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Load-Models","page":"Internal Library","title":"Load Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"load.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_load-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_load","text":"Define load variables\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic","text":"Load pickup constraint used for full restoration problem\n\nrestored load cannot exceed its maximum values\n\nbeginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*\n\nrestored load cannot be shed\n\nbeginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic_1-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic_1","text":"Load pickup constraint (formulation 1)\n\nThe load sequential actions are described below:\n\nbeginalign*\np_d(x_dt)=begincases\n    0  0le t  x_d\n    -p_d  x_dle tle T\nendcases\nendalign*\n\nWe introduce y_dt to indicate whether load d is in status of being energized and x_dt to indicate whether the energization event of load d happens in time t. The formulations are implemented in form_load_logic_2.\n\nFirst, a load has no activity before it is picked up\n\nbeginalign*\n\tlabeleq_load_no_action\nsum_i=1^t-1y_di le (t-1)(1-x_dt)quad forall din Dtin Tbackslash1\nendalign*\n\nSecond, a load is served to the end of the time horizon once it is picked up\n\nbeginalign*\n\tlabeleq_load_served\nsum_i=t^Ty_di ge (T-t+1)x_dtquad forall din D\nendalign*\n\nAnd there exists only one validated load energization moment\n\nbeginalign*\n\tlabeleq_load_one_start\n\tsum_tin Tx_gt =1quad forall gin G\nendalign*\n\nWe can write the load d in time period t as\n\nbeginalign*\n\tlabeleq_load_power\np_d(t) = - y_dtp_d\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic_2-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic_2","text":"Load pickup constraint (formulation 2)\n\nThe load sequential actions are described below:\n\nbeginalign*\np_d(x_dt)=begincases\n    0  0le t  x_d\n    -p_d  x_dle tle T\nendcases\nendalign*\n\nWe introduce x_dt to indicate whether load d is started at time period t. The formulations are implemented in form_load_logic_2.\n\nThe load d consumption at time t can be expressed as:\n\nbeginalign*\n    p_dt=sum_i=1^tx_dip_g(it)quad forall tin T\nendalign*\n\nThe load can only be started once\n\nbeginalign*\nsum_tin Tx_dt=1\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic_3-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic_3","text":"Load pickup constraint (formulation 3)\n\nThe load sequential actions are described below:\n\nbeginalign*\np_d(x_dt)=begincases\n    0  0le t  x_d\n    -p_d  x_dle tle T\nendcases\nendalign*\n\nIf t-x_d0, p_dt=0. Introduce positive large number M and binary variable e_dt. Build t-x_d0Leftrightarrow e_dt=1 and t-x_dgeq 0 Leftrightarrow e_dt=0, where e_dt=1 indicates load d is off-line.\n\nbeginalign*\n    beginaligned\n        t - x_d leq M (1- e_dt) \n        t - x_d geq -M e_dt \n        0 leq p_dt leq M  (1- e_dt)\n        -M  e_dt leq p_dt + p_d leq M  e_dt\n    endaligned\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic_4-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic_4","text":"Load pickup constraint (formulation 4) Provide flexible load dispatch\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Power-Flow-Models","page":"Internal Library","title":"Power Flow Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"flow.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_flow-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_flow","text":"Define flow variable\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_branch-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_branch","text":"Branch (power flow) constraints\n\nlinearized power flow\n\nbeginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_nodal-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_nodal","text":"Form the nodal constraints:\n\nvoltage constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized\n\nbeginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_jt - v^min_j(1-x_ijt)\nendalign*\n\nangle difference constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized\n\n beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-a_jt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*\n\ngenerator and bus energizing logics\nenergized line cannot be shut down\nbus should be energized before the connected genertor being on\n\nbeginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*\n\nbus energized constraints\nbus energized indicating generator energized\nenergized buses cannot be shut down\n\nbeginalign*\n v^minu_it leq vb_it leq v^maxu_it \n v_it - v^max(1-u_it) leq vb_it leq v_it - v^min(1-u_it)\n u_gt = y_gt\n u_it geq u_it-1\nendalign*\n\nnodal power balance constraint\n\nbeginalign*\n sum_bin ip_bt=sum_gin ipg_gt-sum_lin ipl_lt-Gs(2vb_it-u_it)\n sum_bin iq_bt=sum_gin iqg_gt-sum_lin iql_lt+Bs(2vb_it-u_it)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Renewable-Models","page":"Internal Library","title":"Renewable Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"renewable.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_wind-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_wind","text":"Define wind generator variables\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_wind_saa_1-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.form_wind_saa_1","text":"Form wind power dispatch chance constraints approximated by Sample Averaged Approximation This function is associated with wind activation 1 option: wind data from normal distribution\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_wind_saa_2-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.form_wind_saa_2","text":"Form wind power dispatch chance constraints approximated by Sample Averaged Approximation This function is associated with wind activation 2 option: wind data from real time series in a Dictionary\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_wind_saa_3-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.form_wind_saa_3","text":"Form wind power dispatch chance constraints approximated by Sample Averaged Approximation This function is associated with wind activation 3 option: wind data given by an estimated density The chance constraints in sample-average approximation can be enforced into samples through all periods or individual periods\n\nMode 1: The chance constraints can be enforced into samples through all periods\nMode 2: The chance constraints can be enforced into samples through individual periods\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Util-Functions","page":"Internal Library","title":"Util Functions","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"util.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.load_gen-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.load_gen","text":"Load generator data with respect to restoration\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.load_network-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.load_network","text":"Load network data\n\n\n\n\n\n","category":"method"},{"location":"ch3_sec3_dev_package_org.html#Package-Organization","page":"Package Organization","title":"Package Organization","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#Option-1","page":"Package Organization","title":"Option 1","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"We could build one main module called EGRIP and several submodules.","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"In this way, we will declare certain submodule to access its function in another module once the source code is loaded into LOAD_PATH.","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"For example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"Then, in a testing script, we can use the package by","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"using EGRIP\nfun_bs()","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"In addition, we can use the module independently from EGRIP","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"using PowerFlow\nfun_pf()","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"A different but not good way to do include file.","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"This is suggested to do the include in the main module. And once it is loaded to LOAD_PATH, every included script is accessible.","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\ninclude(\"power_flow.jl\")\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#Option-2","page":"Package Organization","title":"Option 2","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"We just build one main module EGRIP. The rest functionalities are implemented by functions in different scripts. Then, we just need to include the scripts in the main module. Once the main module is loaded into LOAD_PATH, we can these functions freely between different scripts without further declaration. Some Julia packages like PowerModels.jl are organized in this way. Take an example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"function func_pf()\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html","page":"Package Organization","title":"Package Organization","text":"function func_lr()\n  func_pf()\nend","category":"page"},{"location":"ch2_sec1_library_public.html#Public-Library","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#Formulation-Function","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec1_library_public.html","page":"Public Library","title":"Public Library","text":"solve_restoration_full\nsolve_restoration_part\nsolve_section\nsolve_startup","category":"page"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration_full","page":"Public Library","title":"EGRIP.solve_restoration_full","text":"Solve full restoration problem (The restoration problem could be partial or full restorations)\n\nFull restoration problem assumes that the entire network is broken down.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration_part","page":"Public Library","title":"EGRIP.solve_restoration_part","text":"Solve partial restoration problem (The restoration problem could be partial or full restorations)\n\nPartial restoration problem assumes that a part of the network is still functioning.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_section","page":"Public Library","title":"EGRIP.solve_section","text":"Solve sectionalization problem for restoration preparedness\n\nProblem type: The sectionalization problem could assign all buses to certain sections or only critical buses.\nInputs:\nnetwork data directory\nrestoration data directory\nresult storage directory\ngap\nOutput:\nJSON file of network data of each section\nConstraints:\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_startup","page":"Public Library","title":"EGRIP.solve_startup","text":"Solve generator start-up problem\n\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nformulation types\nspecifications of wind power\nwind activation 0 denotes no wind will support the restoration\nwind activation 1 denotes wind will support the restoration with its distribution as normal\nwind activation 2 denotes wind will support the restoration with time seires wind data\nwind activation 3 denotes wind will support the restoration with real quantile and interpolation (linear, cubic, or spline)\nif wind activation = 3, then real wind power density will be specified in wind_data\nThe followings are the keyword arguments\nwind_data: time series wind data\nsaa_mode: different chance constraints enforcement in sample average approximations\nOutput: Generator start-up sequence\nConstraints:\ngenerato cranking\nload pickup\npower balance\n\n\n\n\n\n","category":"function"},{"location":"ch4_sec1_literature.html#Literature-Review","page":"Literature Review","title":"Literature Review","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"There are mainly five steps for power network restoration after a partial or full outage:","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Restoration time estimation\nSectionalization\nGenerator start-up optimization\nPath search\nLoad pickup","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"The aforementioned problems have been studied in a separated manner. On the other hand, some researchers are focusing on solving the integrated problems. In addition, many factors such as dynamic security, black-start resource allocation, crew routing and transmission & distribution co-restoration have also been investigated. Here, we will have a brief review of current literature.","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"It is worth mentioning that there are already review papers on this topic:","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"D. Lindenmeyer, H. W. Dommel, and M. M. Adibi, “Power system restoration - a bibliographical survey,” Int. J. Electr. Power Energy Syst., vol. 23, no. 3, pp. 219–227, 2001.\nY. Liu, R. Fan, and V. Terzija, “Power system restoration: a literature review from 2006 to 2016,” J. Mod. Power Syst. Clean Energy, vol. 4, no. 3, pp. 332–341, 2016.","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"In addition, the following paper describes a holistic toolkit with different modules solving aforementioned restoration perspectives:","category":"page"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Y. Hou, C. C. Liu, K. Sun, P. Zhang, S. Liu, and D. Mizumura, “Computation of milestones for decision support during system restoration,” IEEE Trans. Power Syst., vol. 26, no. 3, pp. 1399–1409, 2011.","category":"page"},{"location":"ch4_sec1_literature.html#.-Restoration-time-estimation","page":"Literature Review","title":"1. Restoration time estimation","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nA. Assis Mota, L. T. M. Mota, and A. Morelato, “Visualization of power system restoration plans using CPM/PERT graphs,” IEEE Trans. Power Syst., vol. 22, no. 3, pp. 1322–1329, 2007. ––––––- ––-\nR. B. Duffey and T. Ha, “The probability and timing of power system restoration,” IEEE Trans. Power Syst., vol. 28, no. 1, pp. 3–9, 2013. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Sectionalization","page":"Literature Review","title":"2. Sectionalization","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nJ. J. Joglekar and Y. P. Nerkar, “A different approach in system restoration with special consideration of Islanding schemes,” Int. J. Electr. Power Energy Syst., vol. 30, no. 9, pp. 519–524, 2008. ––––––- ––-\nS. Nourizadeh, S. A. Nezam Sarmadi, M. J. Karimi, and A. M. Ranjbar, “Power system restoration planning based on Wide Area Measurement System,” Int. J. Electr. Power Energy Syst., vol. 43, no. 1, pp. 526–530, 2012. ––––––- ––-\nJ. Quirós-Tortós, P. Wall, L. Ding, and V. Terzija, “Determination of sectionalising strategies for parallel power system restoration: A spectral clustering-based methodology,” Electr. Power Syst. Res., vol. 116, pp. 381–390, 2014. ––––––- ––-\nJ. Quirós-Tortós, M. Panteli, P. Wall, and V. Terzija, “Sectionalising methodology for parallel system restoration based on graph theory,” IET Gener. Transm. Distrib., vol. 9, no. 11, pp. 1216–1225, 2015. ––––––- ––-\nL. Sun et al., “Network partitioning strategy for parallel power system restoration,” IET Gener. Transm. Distrib., vol. 10, no. 8, pp. 1883–1892, 2016. ––––––- ––-\nN. Ganganath, J. V. Wang, X. Xu, C. T. Cheng, and C. K. Tse, “Agglomerative clustering-based network partitioning for parallel power system restoration,” IEEE Trans. Ind. Informatics, vol. 14, no. 8, pp. 3325–3333, 2018. ––––––- ––-\nP. Demetriou, M. Asprou, and E. Kyriakides, “A real-time controlled islanding and restoration scheme based on estimated states,” IEEE Trans. Power Syst., vol. 34, no. 1, pp. 606–615, 2019. ––––––- ––-\nG. Patsakis, D. Rajan, I. Aravena, and S. Oren, “Strong Mixed-Integer Formulations for Power System Islanding and Restoration,” IEEE Trans. Power Syst., vol. 34, no. 6, pp. 4880–4888, 2019. ––––––- ––-\nJ. Zhao et al., “Robust Distributed Coordination of Parallel Restored Subsystems in Wind Power Penetrated Transmission System,” IEEE Trans. Power Syst., vol. 8950, no. c, pp. 1–1, 2020. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Generator-start-up-optimization","page":"Literature Review","title":"3. Generator start-up optimization","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nW. Sun, C. C. Liu, and L. Zhang, “Optimal generator start-up strategy for bulk power system restoration,” IEEE Trans. Power Syst., vol. 26, no. 3, pp. 1357–1366, 2011. ––––––- ––-\nX. Gu, W. Liu, and C. Sun, “Optimisation for unit restarting sequence considering decreasing trend of unit start-up efficiency after a power system blackout,” IET Gener. Transm. Distrib., vol. 10, no. 16, pp. 4187–4196, 2016. ––––––- ––-\nY. Zhao, Z. Lin, Y. Ding, Y. Liu, L. Sun, and Y. Yan, “A model predictive control based generator start-up optimization strategy for restoration with microgrids as black-start resources,” IEEE Trans. Power Syst., vol. 33, no. 6, pp. 7189–7203, 2018. Motivation: microgrids as black-start resources and address uncertainty; Methood: MPC + scenario reduction using mass transportation problem; no power flow models ––-\nR. Sun, Y. Liu, and L. Wang, “An online generator start-up algorithm for transmission system self-healing based on mcts and sparse autoencoder,” IEEE Trans. Power Syst., vol. 34, no. 3, pp. 2061–2070, 2019. Motivation: the shortcomings of offline restoration plan; Method: Expert system based online generator start-up system ==> Monte Carlo tree search and sparse autoencoder Western Shandong Power Grid of China\nX. Gu, G. Zhou, S. Li, and T. Liu, “Global optimisation model and algorithm for unit restarting sequence considering black-start zone partitioning,” IET Gener. Transm. Distrib., vol. 13, no. 13, pp. 2652–2663, 2019. ––––––- ––-\nL. Sun, W. Liu, C. Y. Chung, M. Ding, R. Bi, and L. Wang, “Improving the restorability of bulk power systems with the implementation of a wf-bess system,” IEEE Trans. Power Syst., vol. 34, no. 3, pp. 2366–2377, 2019. Motivation: adtively dispatch wind and energy storage; Method: define restorability index ==> consider uncertainty and scenario reduction ==> optimal dispatch of wind and energy storage ==> Benders decomposition with restoration as master and dispatch as slave Guangdong power system in China\nL. Sun, Z. Lin, Y. Xu, F. Wen, C. Zhang, and Y. Xue, “Optimal Skeleton-Network Restoration Considering Generator Start-Up Sequence and Load Pickup,” IEEE Trans. Smart Grid, vol. 10, no. 3, pp. 3174–3185, 2019. Motivation: integrate startup and transmission line selection; Method: sequentially solve three problems: generator startup, network building and load pickup IEEE 39-bus; Guangdong power system in China","category":"page"},{"location":"ch4_sec1_literature.html#.-Path-search","page":"Literature Review","title":"4. Path search","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nY. Liu and X. Gu, “Skeleton-network reconfiguration based on topological characteristics of scale-free networks and discrete particle swarm optimization,” IEEE Trans. Power Syst., vol. 22, no. 3, pp. 1267–1274, 2007. ––––––- ––-\nC. Wang, V. Vittal, V. S. Kolluri, and S. Mandal, “PTDF-based automatic restoration path selection,” IEEE Trans. Power Syst., vol. 25, no. 3, pp. 1686–1695, 2010. ––––––- ––-\nF. Edström and L. Söder, “On spectral graph theory in power system restoration,” IEEE PES Innov. Smart Grid Technol. Conf. Eur., 2011. ––––––- ––-\nW. Sun and C. C. Liu, “Optimal transmission path search in power system restoration,” Proc. IREP Symp. Bulk Power Syst. Dyn. Control - IX Optim. Secur. Control Emerg. Power Grid, IREP 2013, pp. 0–4, 2013. ––––––- ––-\nY. Xie, K. Song, Q. Wu, and Q. Zhou, “Orthogonal genetic algorithm based power system restoration path optimization,” Int. Trans. Electr. Energy Syst., vol. 28, no. 12, pp. 1–17, 2018. ––––––- ––-\nS. Liao et al., “An improved two-stage optimization for network and load recovery during power system restoration,” Appl. Energy, vol. 249, no. January, pp. 265–275, 2019. ––––––- ––-\nS. Li, X. Gu, G. Zhou, and Y. Li, “Optimisation and comprehensive evaluation of alternative energising paths for power system restoration,” IET Gener. Transm. Distrib., vol. 13, no. 10, pp. 1923–1932, 2019. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Load-pickup","page":"Literature Review","title":"5. Load pickup","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nZ. Qin, Y. Hou, C. C. Liu, S. Liu, and W. Sun, “Coordinating generation and load pickup during load restoration with discrete load increments and reserve constraints,” IET Gener. Transm. Distrib., vol. 9, no. 15, pp. 2437–2446, 2015. ––––––- ––-\nA. Gholami and F. Aminifar, “A Hierarchical Response-Based Approach to the Load Restoration Problem,” IEEE Trans. Smart Grid, vol. 8, no. 4, pp. 1700–1709, 2017. ––––––- ––-\nA. Golshani, W. Sun, and K. Sun, “Real-Time Optimized Load Recovery Considering Frequency Constraints,” IEEE Trans. Power Syst., vol. 34, no. 6, pp. 4204–4215, 2019. ––––––- ––-\nJ. Zhao, H. Wang, Y. Liu, R. Azizipanah-Abarghooee, and V. Terzija, “Utility-oriented online load restoration considering wind power penetration,” IEEE Trans. Sustain. Energy, vol. 10, no. 2, pp. 706–717, 2019. ––––––––––––– ––––\nJ. Zhao, Y. Liu, H. Wang, and Q. Wu, “Receding horizon load restoration for coupled transmission and distribution system considering load-source uncertainty,” Int. J. Electr. Power Energy Syst., vol. 116, no. July 2019, p. 105517, 2020. ––––––––––––– ––––\nJ. Zhao, H. Wang, Q. Wu, N. D. Hatziargyriou, and F. Shen, “Distributed Risk-limiting Load Restoration for Wind Power Penetrated Bulk System,” IEEE Trans. Power Syst., vol. 8950, no. c, pp. 1–1, 2020. ––––––––––––– ––––","category":"page"},{"location":"ch4_sec1_literature.html#Integrated-Methods","page":"Literature Review","title":"Integrated Methods","text":"","category":"section"},{"location":"ch4_sec1_literature.html","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nQiu, Feng, and Peijie Li. \"An integrated approach for power system restoration planning.\" Proceedings of the IEEE 105, no. 7 (2017): 1234-1252. sequentially integrated method: sectionalization==>optimize generator start-up==>path search==>solution refinement IEEE 30-bus, IEEE 118-bus\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, and J. Tong, “Two-Stage Adaptive Restoration Decision Support System for a Self-Healing Power Grid,” IEEE Trans. Ind. Informatics, vol. 13, no. 6, pp. 2802–2812, 2017. ––––––––––––– ––––\nY. Jiang et al., “Blackstart capability planning for power system restoration,” Int. J. Electr. Power Energy Syst., vol. 86, pp. 127–137, 2017. ––––––––––––– ––––\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, J. Wang, and F. Qiu, “Coordination of Wind Farm and Pumped-Storage Hydro for a Self-Healing Power Grid,” IEEE Trans. Sustain. Energy, vol. 9, no. 4, pp. 1910–1920, 2018. ––––––––––––– ––––\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, and Y. Hou, “Incorporating Wind Energy in Power System Restoration Planning,” IEEE Trans. Smart Grid, vol. 10, no. 1, pp. 16–28, 2019. ––––––––––––– ––––\nW. Liu, J. Zhan, C. Y. Chung, and L. Sun, “Availability Assessment Based Case-Sensitive Power System Restoration Strategy,” IEEE Trans. Power Syst., vol. 35, no. 2, pp. 1432–1445, 2020. ––––––––––––– ––––","category":"page"},{"location":"ch1_sec3_formulations.html#Problem-Formulation","page":"Mathematical Model","title":"Problem Formulation","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"EGRIP.jl currently provides two types of restoration problem formulations:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Restoration with Network Energization and Power Flow: This problem formulation models the detailed network energization sequences and power flow constraints. The obtained results can be highly reliable but the computation complexity is high.\nGenerator Start-up Sequence Optimization: This problem formulation focuses on the optimal generator start-up sequence, which is essential in the overall restoration problem. Here the power balance constraint is considered instead of the network energization and power flow constraints. The computation complexity is low but the results may need further verification.","category":"page"},{"location":"ch1_sec3_formulations.html#Restoration-with-Network-Energization-and-Power-Flow","page":"Mathematical Model","title":"Restoration with Network Energization and Power Flow","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The problem formulations are implemented in function solve_restoration_full.","category":"page"},{"location":"ch1_sec3_formulations.html#Sets,-Parameters-and-Variables","page":"Mathematical Model","title":"Sets, Parameters and Variables","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\nmboxIndices and Sets   \n ijin N mbox - buses \n bin B mbox - branches \n gin G mbox - generators \n lin L mbox - loads \n\nmboxParameters   \n Pcr_g quadforall g in G mbox - generator cranking power power needed for the unit to be normally functional\n Tcr_g quadforall g in G mbox - generator cranking time time needed for the unit to be normally functional\n Krp_g quadforall g in G mbox - generator ramping rate \n\nmboxBinary Variables   \n x_ijt mbox - status of line ij at time t\n y_gt mbox - status of generator g at time t\n u_it mbox - status of bus i at time t\n\nmboxContinuous Variables   \n v_it mbox - voltage of bus i at time t\n a_it mbox - relative angle of bus i at time t\n vl_ijt mbox - supplementary variables for voltage of bus i (connected to bus j) at time t\n vb_it mbox - supplementary variables for voltage of bus i at time t\n al_ijt mbox - supplementary variables for relative angle of bus i (connected to bus j) at time t\n pl_lt mbox - active power of load l at time t\n ql_lt mbox - reactive power of load l at time t\n pg_lt mbox - active power of generator g at time t\n qg_lt mbox - reactive power of generator g at time t\n p_bijt mbox - active power flow of branch b (bus i and j) at time t\n q_bijt mbox - reactive power flow of branch b (bus i and j) at time t\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Power-Flow-Model","page":"Mathematical Model","title":"Power Flow Model","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations of branch constraints are implemented in function form_branch. Here the linearized AC power flow model is considered.","category":"page"},{"location":"ch1_sec3_formulations.html#Linearized-AC-power-flow","page":"Mathematical Model","title":"Linearized AC power flow","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Expanding the AC power flows about v_i=v_j=1, α_ij=0 and making small-angle approximations sinα_ij=α_ij and cosα_ij=1 yielding linearized AC power flow","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n p_ijt=G_ii(2v_it-1) + G_ij(v_it + v_jt-1) + B_ijsinα_ij\n q_ijt=-B_ii(2v_it-1) - B_ij(v_it + v_jt-1) + G_ijcosα_ij\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"where voltage and reactive power are retained.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"(Ref: Trodden, Paul A., Waqquas Ahmed Bukhsh, Andreas Grothey, and Ken IM McKinnon. \"Optimization-based islanding of power networks using piecewise linear AC power flow.\" IEEE Transactions on Power Systems 29, no. 3 (2013): 1212-1220.)","category":"page"},{"location":"ch1_sec3_formulations.html#Linearized-AC-power-flow-with-bus-and-line-energization","page":"Mathematical Model","title":"Linearized AC power flow with bus and line energization","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Nodal-Constraint-Model","page":"Mathematical Model","title":"Nodal Constraint Model","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations of nodal constraints are implemented in function form_nodal.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Voltage Constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_jt - v^min_j(1-x_ijt)\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Angle Difference Constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":" beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-a_jt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Generator and Bus Energizing Logics\non-line generator cannot be shut down\nbus should be energized before the connected genertor being on","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Bus Energized Constraints\nbus energized indicating generator energized\non-line buses cannot be shut down","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n v^minu_it leq vb_it leq v^maxu_it \n v_it - v^max(1-u_it) leq vb_it leq v_it - v^min(1-u_it)\n u_gt = y_gt\n u_it geq u_it-1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Nodal Power Balance Constraint","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n sum_bin ip_bt=sum_gin ipg_gt-sum_lin ipl_lt-Gs(2vb_it-u_it)\n sum_bin iq_bt=sum_gin iqg_gt-sum_lin iql_lt+Bs(2vb_it-u_it)\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Generator-Cranking-Model","page":"Mathematical Model","title":"Generator Cranking Model","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations of generator cranking constraints are implemented in function form_gen_cranking_1.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The capacity curve for non-black start generator is simplifed and modeled as a piecewise linear function of time shown below.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"(Image: Capacity curve){#fig:capacity_curve}","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"(Ref: Qiu, Feng, and Peijie Li. \"An integrated approach for power system restoration planning.\" Proceedings of the IEEE 105, no. 7 (2017): 1234-1252.)","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Once a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time. \"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"set non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Mathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability. There will be the following scenarios","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"All scenarios can be formulated as follows:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gTcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Generator-Dispatch-Model","page":"Mathematical Model","title":"Generator Dispatch Model","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in function form_gen_logic.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Generator ramping rate constraint","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Black-start unit is determined by the cranking power","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"On-line generators cannot be shut down","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\ny_gt = y_gt+1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Load-Dispatch-Model","page":"Mathematical Model","title":"Load Dispatch Model","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in function form_load_logic.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"restored load cannot exceed its maximum values","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"restored load cannot be shed","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Generator-Start-up-Sequence-Optimization","page":"Mathematical Model","title":"Generator Start-up Sequence Optimization","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"In the generator start-up sequence optimization problem, we consider the same cranking curve. Instead of the power flow constraints, we will use the network power balance constraint. We do not dispatch the generator and load by assuming an automatic sequential actions after being started. The generator sequential actions are described below:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\np_g(x_gt)=begincases\n    0  0le tx_g\n    -c_g  x_gle t  x_g+t_g^c\n    r_g(t-x_g-t_g^c)  x_g+t_g^cleq t  x_g+t_g^c+t_g^r\n    p^mboxmax  x_g+t_g^c+t_g^rleq t leq T\nendcases\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The load sequential actions are described below:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\np_d(x_dt)=begincases\n    0  0le t  x_d\n    -p_d  x_dle tle T\nendcases\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in function solve_startup. In solve_startup, there are several different formulations to solve the problem.","category":"page"},{"location":"ch1_sec3_formulations.html#Formulation-1","page":"Mathematical Model","title":"Formulation 1","text":"","category":"section"},{"location":"ch1_sec3_formulations.html#Generator-action-logics","page":"Mathematical Model","title":"Generator action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"We introduce binary variables y_gt, z_gt, and u_gt to indicate whether generator g is in status of cranking, ramping, or full capacity in time period t, respectively. We introduce binary variable x_gt to indicate whether generator g is started in time period t. The formulations are implemented in function form_gen_cranking_1.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"First, a NBS generator has no activity before it is started","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\nbeginaligned\n\t\t(t-1)(1-x_gt) ge sum_i=1^t-1y_giquadforall gin G tin Tbackslash1\nendaligned\nbeginaligned\n\t(t+t^c_g-1)(1-x_gt) ge sum_i=1^f(t) z_giquadforall gin G tin T\nendaligned\nbeginaligned\n\t(t+t^c_g+t^r_g-1)(1-x_gt) ge sum_i=1^g(t)u_giquadforall gin G tin T\nendaligned\n f(t)=minTt+t^c_g-1g(t)=minTt+t^c_g +t^r_g-1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Second, once started, a cranking is followed","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\nsum_i=t^f(t) y_gige x_gttimesminT-t t^c_gquad forall tin T\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Third, once cranking is finished, a ramping is followed","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_gen_ramp\nsum_i=t+t^r_g-1^g(t) z_gige x_gttimesminT-t t^r_gquad forall tin T\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Once the generator reaches to its maximum value, it should stay in this status","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_gen_max\n\tu_gtgeq u_gt-1quad forall tin Tbackslash1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Additionally, in each stage each generator will have one status being activated, i.e.,","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_gen_one_status\ny_gi + z_gi + u_gileq 1quad forall tin T\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"And there exists only one validated generator start-up moment","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_gen_one_start\n\tsum_tin Tx_gt =1quad forall gin G\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"We can write the generation output of unit g in time period t as","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_gen_power\np_g(t) = -c_gy_gt+ sum_i=1^tz_gir_g\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Load-action-logics","page":"Mathematical Model","title":"Load action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Similarly, a load will undergo two stages. We introduce y_dt to indicate whether load d is in status of being energized and x_dt to indicate whether the energization event of load d happens in time t. The formulations are implemented in form_load_logic_1.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"First, a load has no activity before it is picked up","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_load_no_action\nsum_i=1^t-1y_di le (t-1)(1-x_dt)quad forall din Dtin Tbackslash1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Second, a load is served to the end of the time horizon once it is picked up","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_load_served\nsum_i=t^Ty_di ge (T-t+1)x_dtquad forall din D\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"And there exists only one validated load energization moment","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_load_one_start\n\tsum_tin Tx_gt =1quad forall gin G\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"We can write the load d in time period t as","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tlabeleq_load_power\np_d(t) = - y_dtp_d\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Power-balance-constraint","page":"Mathematical Model","title":"Power balance constraint","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The major constraints in restoration process is that, at any moment, the total generation capacity minus loads cannot be negative, which can be expressed as follows","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\nbeginaligned\n\tlabeleq_capacity_wo_renewable\nsum_iin Gp_i(t) -sum_iin Dd_i(t) ge 0quad forall tin T\nendaligned\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Objective","page":"Mathematical Model","title":"Objective","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\t\tmin sum_g in Gsum_tin Ttx_gt+sum_d in Dsum_tin Ttx_dt\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Formulation-2","page":"Mathematical Model","title":"Formulation 2","text":"","category":"section"},{"location":"ch1_sec3_formulations.html#Generator-action-logics-2","page":"Mathematical Model","title":"Generator action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in function form_gen_cranking_2. Let p_g(t) represent the power output of generator g in time period t. Note that, p_g(t) depends on start time x_g. Once x_g is known, power output in every time period can be calculated with the following formula.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tp_g(x_gt)=begincases\n\t\t0  0le tx_g\n\t\t-c_g  x_gle tx_g+t_g^c\n\t\tr_g(t-x_g-t_g^c)  x_g+t_g^cle tle x_g+t_g^c+t_g^r\n\t\tp^mboxmax  x_g+t_g^c+t_g^rle tle T\n\tendcases\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"where T is restoration horizon. The term -c_g indicates that generator g is in the cranking status and consuming power.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"With slight abuse of notation, let x_gtin01 forall g in G tin T represent whether generator i is started in time period t, where G is the set of non-black start (NBS) generators. Therefore, the function p_g(t) can be rewritten as follows:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tp_g(t) = sum_i=1^tx_gitimes p_g(it)\n\tsum_tin Tx_gt=1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Note that p_g(it) is a constant.","category":"page"},{"location":"ch1_sec3_formulations.html#Load-action-logics-2","page":"Mathematical Model","title":"Load action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in form_load_logic_1. A load d_i(t) can be expressed similarly.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tp_d(x_dt)=begincases\n\t\t0  0le tx_d\n\t\t-p_d  x_dle tle T\n\tendcases\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"where x_d is the pick-up time of load d. Similarly for load d:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tp_d(t) = sum_i=1^tx_ditimes  p_d(it)\n\tsum_tin Tx_dt=1\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Power-balance-constraint-2","page":"Mathematical Model","title":"Power balance constraint","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The major constraints in restoration process is that, at any moment, the total generation capacity minus loads cannot be negative, which can be expressed as follows:","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tsum_iin Gp_i(t) -sum_iin Dd_i(t) ge 0quad forall tin T\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Objective-2","page":"Mathematical Model","title":"Objective","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The overall generator start-up formulations without renewable participation read as follow","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\t\tmin sum_g in Gsum_tin Ttx_gt+sum_d in Dsum_tin Ttx_dt\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Formulation-3","page":"Mathematical Model","title":"Formulation 3","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"Here we use big-M technique to express the logical conditions of the sequential generator and load actions. The formulations are implemented in function form_gen_cranking_3.","category":"page"},{"location":"ch1_sec3_formulations.html#Generator-action-logics-3","page":"Mathematical Model","title":"Generator action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"If t-x_g0, p_gt=0. Introduce positive large number M and binary variable a_gt. Build t - x_g  0 Leftrightarrow a_gt=1 and t - x_g geq 0 Leftrightarrow a_gt=0, where a_gt=1 indicates generator g is off-line.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"        beginalign*\n\t\tbeginaligned\n\t\t\tt - x_gleq M (1- a_gt) \n\t\t\tt-x_g geq -M a_gt \n\t\t\t-M  (1- a_gt) leq p_gt\n\t\t\t p_gtleq M  (1- a_gt)\n\t\tendaligned\n        endalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"If x_gle t  and t  x_g+t_g^c, p_gt=-c_g. Introduce positive large number M and binary variable b_gt. Build t  x_g+t_g^c Leftrightarrow b_gt=1 and t geq x_g+t_g^c Leftrightarrow b_gt=0, where b_gt=1 indicates generator g is at the cranking stage.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\t\tbeginaligned\n\t\t\tt - x_g- t_g^c leq M (1- b_gt) \n\t\t\tt - x_g- t_g^cgeq -M b_gt \n\t\t\t-M  (1+a_gt- b_gt) leq p_gt + c_g\n\t\t\t p_gt + c_gleq M  (1+a_gt- b_gt)\n\t\tendaligned\n\tendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"If t   x_g+t_g^c+t_g^r, p_gt=r_g(t-x_g-t_g^c). Introduce positive large number M and binary variable c_gt. Build t  x_g+t_g^c+t_g^r Leftrightarrow c_gt=1 and t geq x_g+t_g^c+t_g^r Leftrightarrow c_gt=0, where c_gt=1 indicates generator g is at the ramping stage.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\t\tbeginaligned\n\t\t\tt - (x_g+t_g^c+t_g^r) leq M (1- c_gt) \n\t\t\tt - (x_g+t_g^c+t_g^r)geq -M c_gt \n\t\t\t-M  (1+a_gt+ b_gt- c_gt) leq p_gt - r_g(t-x_g-t_g^c)\n\t\t\t p_gt - r_g(t-x_g-t_g^c)leq M  (1+a_gt+ b_gt- c_gt)\n\t\tendaligned\n\tendalign*","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"For the last stage, we do not need to introduce new variables.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n-M  (a_gt+ b_gt + c_gt) leq p_gt - p^mboxmax \n\t\t\t p_gt - p^mboxmax leq M  (a_gt+ b_gt + c_gt)\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Load-action-logics-3","page":"Mathematical Model","title":"Load action logics","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The formulations are implemented in form_load_logic_3.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"If t-x_d0, p_dt=0. Introduce positive large number M and binary variable e_dt. Build t-x_d0Leftrightarrow e_dt=1 and t-x_dgeq 0 Leftrightarrow e_dt=0, where e_dt=1 indicates load d is off-line.","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n    beginaligned\n        t - x_d leq M (1- e_dt) \n        t - x_d geq -M e_dt \n        0 leq p_dt leq M  (1- e_dt)\n        -M  e_dt leq p_dt + p_d leq M  e_dt\n    endaligned\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Power-balance-constraint-3","page":"Mathematical Model","title":"Power balance constraint","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"The major constraints in restoration process is that, at any moment, the total generation capacity minus loads cannot be negative, which can be expressed as follows","category":"page"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\tbeginaligned\n\t\tsum_iin Gp_it -sum_iin Dd_it ge 0quad forall tin T\n\tendaligned\nendalign*","category":"page"},{"location":"ch1_sec3_formulations.html#Objective-3","page":"Mathematical Model","title":"Objective","text":"","category":"section"},{"location":"ch1_sec3_formulations.html","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign*\n\t\tmin sum_g in Gx_g+sum_d in Dx_d\n\tendalign*","category":"page"},{"location":"ch3_sec1_development_overview.html#Development-Overview","page":"Development Overview","title":"Development Overview","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Directory-Tree","page":"Development Overview","title":"Directory Tree","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Dependency","page":"Development Overview","title":"Dependency","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Documentation-Notes","page":"Development Overview","title":"Documentation Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html","page":"Development Overview","title":"Development Overview","text":"We use Documenter.jl.","category":"page"},{"location":"ch3_sec1_development_overview.html#Other-Detailed-Notes","page":"Development Overview","title":"Other Detailed Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html","page":"Development Overview","title":"Development Overview","text":"Code Loading\nPackage Organization","category":"page"},{"location":"index.html#EGRIP.jl-Documentation","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the documentation for EGRIP.jl!","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"EGRIP (Electricity Grid Resilience Improvement Program) is a Julia/MATALB package for power system restoration planning and verification. After a partial or full blackout, the objective of the system operator is to restore the customer services as soon as possible, which is crucial for power system resilience. Power system restoration is an extremely complicated process, involving multiple steps, highly combinatorial operational decisions, and highly nonlinear technical constraints, which make restoration planning an exceptionally challenging task.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The objective of this toolkit is to:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Improve the preparedness of power systems for extreme weather conditions\nEnhance the capability of quick recovery from damages (such as partial or complete blackout)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The holistic framework shown below consists of three main modules: nowcasting weather forecasting, simulation and restoration.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Simulation module provides predictive outages and damages, and dynamic security assessment for restoration plan to guarantee practicality\nRestoration module provides Multi-time scale (resource allocation and operation) multi-level (bulk power system and distribution level) restoration optimization","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Holistic structure)","category":"page"},{"location":"index.html#Optimization-Core","page":"Home","title":"Optimization Core","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The optimization core is designed in a modularize and hierarchical manner to facilitate future algorithm development, multi-purpose usage as well as reduce the coding overhead. It consists of three levels, that is, fundamental function level, ordinary problem level and advanced solution level.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The fundamental function level is to provide basic optimization formulations. Currently it consists of generator dispatch model, generator cranking model, controllable load dispatch model, linearized AC power flow model and AC power flow model as well as data I/O.\nThe ordinary problem level formulates different problems using appropriate functions from both fundamental and its own levels. Currently there are three ordinary problems, that is, load restoration problem, system black-start problem and AC power flow feasibility checking problem. The load restoration problem is to maximize served load under a energized topology. The system black-start problem is to simultaneously energize the system and restore load service through black-start units.\nThe advanced solution level is to either speed up the computation or accommodate new capabilities using both state-of-the-art optimization algorithm and power system domain knowledge. Currently it consists of the multi-resolution restoration algorithm and meta heuristic enhancement. The multi-resolution restoration algorithm is to accelerate the overall solution time by guiding the search of higher-resolution problem using solutions from lower-resolution solutions. The meta heuristic enhancement uses power system domain knowledge and to add additional physical constraints and empirical rules to speed up the computation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Simulation-Core","page":"Home","title":"Simulation Core","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The simulation core is used for the resilience assessment of system under possible extreme events and in the restoration process. The simulation core utilizes the simulation tool based on semi-analytical solutions (SAS). The SAS has enhanced numerical robustness and computational efficiency, which enables the analysis of very complex dynamic processes in large-scale power systems. The SAS-based simulation tool has the following major features:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Flexible customization of event sequences. Users can conveniently define the event sequences through an event list file. The simulation tool supports various types of events, such as adding/tripping components, adding/clearing faults, ramping of load/ generation. The event scheduler dispatches the simulation workflow to simulate the event sequence.\nRich model library. The simulation tool supports steady-state analysis and dynamic simulation. The model library includes dynamic models of synchronous generators, controllers (AVR and turbine governor), static load (e.g. ZIP) and induction motor load, and AGC model. And the model library is still expanding. The simulation tool admits widely supported PSAT data format.\nEnhanced robustness. The SAS as a high-order advanced computational approach with analytical form, has guaranteed numerical convergence to existing solution. Therefore, the SAS users are worry-free of non-convergence issues, and the simulation tool has good capability of performing very complex power system resilience analysis tasks.\nEnhanced efficiency with steady-state & dynamic hybrid simulation. The simulator automatically switches between full-dynamic simulation (where fast transients are significant) and quasi-steady-state (QSS) simulation (where the transients decay and approximately enters steady-state). The hybrid simulation scheme significantly saves computation time compared with the full-dynamic simulation, typically by 30%-70% depending on studied cases.\nFriendly output and visualization functions. The SAS-based simulation tool has a log system that enables printing and recording different levels of events in simulation. After simulation, users can conveniently plot the trajectories of various system states through a specially designed plotting function.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Yichen Zhang, Argonne National Laboratory (yichen.zhang@anl.gov)\nRui Yao, Argonne National Laboratory (ryao@anl.gov)\nFeng Qiu, Argonne National Laboratory (fqiu@anl.gov)","category":"page"},{"location":"index.html#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Based upon work supported by the U.S. Department of Energy Advanced Grid Modeling Program under Grant DE-OE0000875.","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Qiu, Feng, and Peijie Li. An integrated approach for power system restoration planning. Proceedings of the IEEE 105, no. 7 (2017): 1234-1252.","category":"page"},{"location":"index.html#License","page":"Home","title":"License","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"EGRIP, Electricity Grid Resilience Improvement Program\nCopyright © 2020, UChicago Argonne, LLC. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of\n   conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice, this list of\n   conditions and the following disclaimer in the documentation and/or other materials provided\n   with the distribution.\n3. Neither the name of the copyright holder nor the names of its contributors may be used to\n   endorse or promote products derived from this software without specific prior written\n   permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\nOTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Installation\nTutorials\nProblem Formulation\nAdvanced Algorithms","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Public Library\nInternal Library","category":"page"}]
}
