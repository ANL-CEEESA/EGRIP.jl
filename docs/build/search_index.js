var documenterSearchIndex = {"docs":
[{"location":"ch4_sec2_benchmark.html#Benchmark-Testing-1","page":"Benchmark Testing","title":"Benchmark Testing","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#Code-Loading-1","page":"Code Loading","title":"Code Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The current confusion is on how Julia load packages and modules that are not registered through Pkg.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Working-Directory-1","page":"Code Loading","title":"Working Directory","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The working directory, which can be obtained by pwd(), has to be the one containing our packages for things to be loaded correctly.\nWe can add the command cd(@__DIR__) at the beginning of our code to navigate the directory to where our code is running.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Package-Loading-1","page":"Code Loading","title":"Package Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Assmue we would like to use our developed but unregistered package EGRIP.jl at a Julia file named testrun.jl. There are two ways to load EGRIP.jl.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Include-the-package-and-corresponding-modules-1","page":"Code Loading","title":"Include the package and corresponding modules","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can include the main jl file of the package at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory containing `testrun.jl`\ninclude(\"path to the source code from current working directory/src/EGRIP.jl\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through relative path import of the main module since it cannot be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using .EGRIP # It tells Julia to find the module around the current working directory instead of Julia Environment","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Due to the similar reason, other modules in the package cannot be identified by Julia Environment. When module_a in file_module_a.jl needs to use a function fun_b from module_b in file_module_b.jl, we need to do the following at the beginning of file_module_a.jl (assmue file_module_a.jl and file_module_b.jl are in the same directory):","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"include(\"file_module_b.jl\")\nusing .module_b","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, if fun_b has been exported, we can directly access it. Otherwise. we need to use module_b.fun_b. This is not very convenient.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Add-source-code-directory-into-Julia-Environment-1","page":"Code Loading","title":"Add source code directory into Julia Environment","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can make source directory accessible through Julia's LOAD_PATH. We can add the following line at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory `testrun.jl`\npush!(LOAD_PATH,\"path to the source code from current working directory/src/\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through absolute path import of the main module since it can be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using EGRIP # It tells Julia to find the module in Julia Environment LOAD_PATH","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"In addition, all other modules can be used in the same way.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Discussion-on-include-1","page":"Code Loading","title":"Discussion on include","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia’s include is a function, not a simple input redirector (as in C, Fortran, or Matlab).\nEvaluate the contents of a source file in the current context. “The current context” means the global scope of the current module when the evaluation takes place.\nThis function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\nInclude works in the dynamically-current module, not the lexically-current one.\nIt is really a load-time function, not a run-time one.","category":"page"},{"location":"ch1_sec1_install.html#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"For now since EGRIP.jl has not been registered, we need to load the package locally by putting the following code at the beginning of your test script:","category":"page"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")","category":"page"},{"location":"ch2_sec2_library_internal.html#Internal-Library-1","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#Integrated-Restoration-1","page":"Internal Library","title":"Integrated Restoration","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"restoration.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration_full-NTuple{7,Any}","page":"Internal Library","title":"EGRIP.solve_restoration_full","text":"Solve full restoration problem (The restoration problem could be partial or full restorations)\n\nFull restoration problem assumes that the entire network is broken down.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration_part-NTuple{7,Any}","page":"Internal Library","title":"EGRIP.solve_restoration_part","text":"Solve partial restoration problem (The restoration problem could be partial or full restorations)\n\nPartial restoration problem assumes that a part of the network is still functioning.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Sectionalization-Models-1","page":"Internal Library","title":"Sectionalization Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"section.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_section-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.solve_section","text":"Solve sectionalization problem for restoration preparedness\n\nProblem type: The sectionalization problem could assign all buses to certain sections or only critical buses.\nInputs:\nnetwork data directory\nrestoration data directory\nresult storage directory\ngap\nOutput:\nJSON file of network data of each section\nConstraints:\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Generator-Startup-Models-1","page":"Internal Library","title":"Generator Startup Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"startup.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_startup-NTuple{8,Any}","page":"Internal Library","title":"EGRIP.solve_startup","text":"Solve generator start-up problem\n\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Generator start-up sequence\nConstraints:\n\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Generator-Models-1","page":"Internal Library","title":"Generator Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"gen.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_gen-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_gen","text":"Define generator variables\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking","text":"Generator cranking constraint\n\nOnce a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time\n\"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator\nset non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power\nMathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability\nThere will be the following scenarios\n(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g\nAll scenarios can be formulated as follows:\n\nbeginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gTcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_cranking_1-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_cranking_1","text":"Generator cranking constraint (form 1)\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_logic-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_gen_logic","text":"generator status and output constraint\n\ngenerator ramping rate constraint\n\nbeginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*\n\nblack-start unit is determined by the cranking power\n\nbeginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*\n\non-line generators cannot be shut down\n\nbeginalign*\ny_gt = y_gt+1\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Load-Models-1","page":"Internal Library","title":"Load Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"load.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_load-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_load","text":"Define load variables\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic","text":"Load pickup constraint\n\nrestored load cannot exceed its maximum values\n\nbeginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*\n\nrestored load cannot be shed\n\nbeginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic_1-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_load_logic_1","text":"Load pickup constraint form 1\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Power-Flow-Models-1","page":"Internal Library","title":"Power Flow Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"flow.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_flow-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_flow","text":"Define flow variable\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_branch-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_branch","text":"Branch (power flow) constraints\n\nlinearized power flow\n\nbeginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_nodal-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.form_nodal","text":"Form the nodal constraints:\n\nvoltage constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized\n\nbeginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_jt - v^min_j(1-x_ijt)\nendalign*\n\nangle difference constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized\n\n beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-a_jt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*\n\ngenerator and bus energizing logics\nenergized line cannot be shut down\nbus should be energized before the connected genertor being on\n\nbeginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*\n\nbus energized constraints\nbus energized indicating generator energized\nenergized buses cannot be shut down\n\nbeginalign*\n v^minu_it leq vb_it leq v^maxu_it \n v_it - v^max(1-u_it) leq vb_it leq v_it - v^min(1-u_it)\n u_gt = y_gt\n u_it geq u_it-1\nendalign*\n\nnodal power balance constraint\n\nbeginalign*\n sum_bin ip_bt=sum_gin ipg_gt-sum_lin ipl_lt-Gs(2vb_it-u_it)\n sum_bin iq_bt=sum_gin iqg_gt-sum_lin iql_lt+Bs(2vb_it-u_it)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Renewable-Models-1","page":"Internal Library","title":"Renewable Models","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"renewable.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.def_var_wind-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.def_var_wind","text":"Define wind generator variables\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_wind_saa-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.form_wind_saa","text":"Form wind power dispatch chance constraints approximated by Sample Averaged Approximation\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#Util-Functions-1","page":"Internal Library","title":"Util Functions","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"util.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.load_gen-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP.load_gen","text":"Load generator data with respect to restoration\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.load_network-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.load_network","text":"Load network data\n\n\n\n\n\n","category":"method"},{"location":"ch3_sec3_dev_package_org.html#Package-Organization-1","page":"Package Organization","title":"Package Organization","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#Option-1-1","page":"Package Organization","title":"Option 1","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We could build one main module called EGRIP and several submodules.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In this way, we will declare certain submodule to access its function in another module once the source code is loaded into LOAD_PATH.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"For example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"Then, in a testing script, we can use the package by","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using EGRIP\nfun_bs()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In addition, we can use the module independently from EGRIP","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using PowerFlow\nfun_pf()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"A different but not good way to do include file.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"This is suggested to do the include in the main module. And once it is loaded to LOAD_PATH, every included script is accessible.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\ninclude(\"power_flow.jl\")\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#Option-2-1","page":"Package Organization","title":"Option 2","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We just build one main module EGRIP. The rest functionalities are implemented by functions in different scripts. Then, we just need to include the scripts in the main module. Once the main module is loaded into LOAD_PATH, we can these functions freely between different scripts without further declaration. Some Julia packages like PowerModels.jl are organized in this way. Take an example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_pf()\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_lr()\n  func_pf()\nend","category":"page"},{"location":"ch2_sec1_library_public.html#Public-Library-1","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#Formulation-Function-1","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#","page":"Public Library","title":"Public Library","text":"solve_restoration_full\nsolve_restoration_part\nsolve_section\nsolve_startup","category":"page"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration_full","page":"Public Library","title":"EGRIP.solve_restoration_full","text":"Solve full restoration problem (The restoration problem could be partial or full restorations)\n\nFull restoration problem assumes that the entire network is broken down.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration_part","page":"Public Library","title":"EGRIP.solve_restoration_part","text":"Solve partial restoration problem (The restoration problem could be partial or full restorations)\n\nPartial restoration problem assumes that a part of the network is still functioning.\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Restoration plans\nConstraints:\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_section","page":"Public Library","title":"EGRIP.solve_section","text":"Solve sectionalization problem for restoration preparedness\n\nProblem type: The sectionalization problem could assign all buses to certain sections or only critical buses.\nInputs:\nnetwork data directory\nrestoration data directory\nresult storage directory\ngap\nOutput:\nJSON file of network data of each section\nConstraints:\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_startup","page":"Public Library","title":"EGRIP.solve_startup","text":"Solve generator start-up problem\n\nInputs: A set of restoration data in csv format and original system data\nnetwork data directory where data format could be json, matpower and psse\nrestoration data directory\nrestoration_gen: specify initial generator status, cranking specifications and black-start generators\nrestoration_bus: specify initial bus status and its load priority, from where the problem type (partial or full restorations) can be determined\nrestoration_line: specify initial line status, from where the problem type (partial or full restorations) can be determined\nresult storage directory\ngap\nOutput: Generator start-up sequence\nConstraints:\n\n\n\n\n\n\n","category":"function"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Optimization-and-Verification-Workflow-1","page":"Restoration Workflow","title":"Restoration Plan Optimization and Verification Workflow","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Integrated restoration optimization model produces an initial parallel recovery plan\nCranking path module finds transmission path to energize to crank a generator\nTransient stability and static security constraints are validated by simulation\nThree options to fix a restoration plan\nAdd compensation devices\nSwitch to another cranking path\nRe-optimize startup sequences\nIf a restoration plan cannot be repaired (or sacrifice too much solution quality), remove current plan from solution space and resolve the integrated restoration optimization model","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"(Image: Restoration workflow)","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Optimization-1","page":"Restoration Workflow","title":"Restoration Plan Optimization","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#Interactive-Usage-1","page":"Restoration Workflow","title":"Interactive Usage","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"We can load and use the package using:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"First, we need to tell the package where our problem data is. Assume the data is at the same directory of the executing script, then the data can be loaded as:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_network = \"case39.m\"\ndir_case_blackstart = \"BS_generator.csv\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Second, we need to tell the package where our results are going to be stored. Let's save the results in a child folder results:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_result = \"results/\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Then, we define the restoration duration and time steps:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"t_final = 300\nt_step = 100","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"At last, we set the gap for the solver:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"gap = 0.15","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once everything is ready, we can call solve_restoration function to solve the problem:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"solve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Part of the results will be printed once the algorithm terminates.","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Line energization:\nstage 1.0:\nstage 2.0:\nstage 3.0: (8,9) (25,37) (16,17) (20,34) (22,23) (19,20) (22,35) (6,11) (9,39) (13,14) (5,8) (19,33) (26,27) (14,15) (12,13) (10,13) (15,16) (16,24) (12,11) (29,38) (16,19) (23,36) (6,31) (26,29) (23,24) (5,6) (4,14) (17,27) (25,26)\n\nGenerator energization:\nstage 1.0: 39\nstage 2.0:\nstage 3.0: 36 33 38 31 37 34 35\n\nBus energization:\nstage 1.0: 12 1 11 39 19 20 13\nstage 2.0: 18 16 5\nstage 3.0: 2 21 7 26 25 35 34 29 10 9 17 8 22 6 24 4 37 28 38 23 31 14 27 36 15 33","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Detailed results will be stored in results folder under the directory containing the case file.","category":"page"},{"location":"ch1_sec4_workflow.html#Command-Line-Usage-1","page":"Restoration Workflow","title":"Command Line Usage","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Alternatively, we can build a command-line tool. First, we create a script file named solve_bs.jl and write the following Julia code in the script:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP\ndir_case_network = ARGS[1]\ndir_case_blackstart = ARGS[2]\ndir_case_result = ARGS[3]\nt_final = parse(Int64, ARGS[4])\nt_step = parse(Int64, ARGS[5])\ngap = parse(Float64, ARGS[6])\nsolve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Open Terminal and navigate to the directory containing solve_bs.jl.","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"$ cd /path to solve_bs/","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Execute the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"$ julia solve_bs.jl 'case39.m' 'BS_generator.csv' 'results/' 300 100 0.15","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Verification-1","page":"Restoration Workflow","title":"Restoration Plan Verification","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-File-Generation-1","page":"Restoration Workflow","title":"Restoration Plan File Generation","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"This process consists of two steps. The first step is to generate restoration plan file (an event list) using the function generateRestorationPlanFromOpt. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"optResPath: The path containing the optimized restoration plan result\noutFileName: the name of the restoration plan file to be generated\ndataFile: The name of the associated system data file (PSAT format, .m)\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function will output exitflag, which 1 means success and fail otherwise. The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"generateRestorationPlanFromOpt('D:\\Box Sync\\Blackstart_data\\Blackstart_data\\','restoration_plan_test_039.m','d_datane_39_mod_PQ_3')","category":"page"},{"location":"ch1_sec4_workflow.html#Simulation-1","page":"Restoration Workflow","title":"Simulation","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the event list is generated, we can run the simulation using the function runDynamicSimulation. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dataFile: The name of the associated system data file (PSAT format, .m)\nrestSettingFile: the name of the restoration plan file\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"There will be two outpus:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"exitflag=1: run the whole simulation, otherwise: DSA did not finish all the simulation\nmsg: detailed message","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"[flag,msg]=runDynamicSimulation('d_datane_39_mod_PQ_3','restoration_plan_test_039')","category":"page"},{"location":"ch1_sec4_workflow.html#Plots-1","page":"Restoration Workflow","title":"Plots","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the simulation is completed, we could load the simulation data:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Load the *_simp.mat result file (located in ./restoration/)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"and plot the results:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"plotCurves(1,t,stateCurve,SysDataBase,’variableName’)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The results of the IEEE 39-bus system are shown below. (Image: Enhanced Extended-Term Simulation) (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch4_sec1_literature.html#Literature-Review-1","page":"Literature Review","title":"Literature Review","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"There are mainly five steps for power network restoration after a partial or full outage:","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Restoration time estimation\nSectionalization\nGenerator start-up optimization\nPath search\nLoad pickup","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"The aforementioned problems have been studied in a separated manner. On the other hand, some researchers are focusing on solving the integrated problems. In addition, many factors such as dynamic security, black-start resource allocation, crew routing and transmission & distribution co-restoration have also been investigated. Here, we will have a brief review of current literature.","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"It is worth mentioning that there are already review papers on this topic:","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"D. Lindenmeyer, H. W. Dommel, and M. M. Adibi, “Power system restoration - a bibliographical survey,” Int. J. Electr. Power Energy Syst., vol. 23, no. 3, pp. 219–227, 2001.\nY. Liu, R. Fan, and V. Terzija, “Power system restoration: a literature review from 2006 to 2016,” J. Mod. Power Syst. Clean Energy, vol. 4, no. 3, pp. 332–341, 2016.","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"In addition, the following paper describes a holistic toolkit with different modules solving aforementioned restoration perspectives:","category":"page"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Y. Hou, C. C. Liu, K. Sun, P. Zhang, S. Liu, and D. Mizumura, “Computation of milestones for decision support during system restoration,” IEEE Trans. Power Syst., vol. 26, no. 3, pp. 1399–1409, 2011.","category":"page"},{"location":"ch4_sec1_literature.html#.-Restoration-time-estimation-1","page":"Literature Review","title":"1. Restoration time estimation","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nA. Assis Mota, L. T. M. Mota, and A. Morelato, “Visualization of power system restoration plans using CPM/PERT graphs,” IEEE Trans. Power Syst., vol. 22, no. 3, pp. 1322–1329, 2007. ––––––- ––-\nR. B. Duffey and T. Ha, “The probability and timing of power system restoration,” IEEE Trans. Power Syst., vol. 28, no. 1, pp. 3–9, 2013. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Sectionalization-1","page":"Literature Review","title":"2. Sectionalization","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nJ. J. Joglekar and Y. P. Nerkar, “A different approach in system restoration with special consideration of Islanding schemes,” Int. J. Electr. Power Energy Syst., vol. 30, no. 9, pp. 519–524, 2008. ––––––- ––-\nS. Nourizadeh, S. A. Nezam Sarmadi, M. J. Karimi, and A. M. Ranjbar, “Power system restoration planning based on Wide Area Measurement System,” Int. J. Electr. Power Energy Syst., vol. 43, no. 1, pp. 526–530, 2012. ––––––- ––-\nJ. Quirós-Tortós, P. Wall, L. Ding, and V. Terzija, “Determination of sectionalising strategies for parallel power system restoration: A spectral clustering-based methodology,” Electr. Power Syst. Res., vol. 116, pp. 381–390, 2014. ––––––- ––-\nJ. Quirós-Tortós, M. Panteli, P. Wall, and V. Terzija, “Sectionalising methodology for parallel system restoration based on graph theory,” IET Gener. Transm. Distrib., vol. 9, no. 11, pp. 1216–1225, 2015. ––––––- ––-\nL. Sun et al., “Network partitioning strategy for parallel power system restoration,” IET Gener. Transm. Distrib., vol. 10, no. 8, pp. 1883–1892, 2016. ––––––- ––-\nN. Ganganath, J. V. Wang, X. Xu, C. T. Cheng, and C. K. Tse, “Agglomerative clustering-based network partitioning for parallel power system restoration,” IEEE Trans. Ind. Informatics, vol. 14, no. 8, pp. 3325–3333, 2018. ––––––- ––-\nP. Demetriou, M. Asprou, and E. Kyriakides, “A real-time controlled islanding and restoration scheme based on estimated states,” IEEE Trans. Power Syst., vol. 34, no. 1, pp. 606–615, 2019. ––––––- ––-\nG. Patsakis, D. Rajan, I. Aravena, and S. Oren, “Strong Mixed-Integer Formulations for Power System Islanding and Restoration,” IEEE Trans. Power Syst., vol. 34, no. 6, pp. 4880–4888, 2019. ––––––- ––-\nJ. Zhao et al., “Robust Distributed Coordination of Parallel Restored Subsystems in Wind Power Penetrated Transmission System,” IEEE Trans. Power Syst., vol. 8950, no. c, pp. 1–1, 2020. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Generator-start-up-optimization-1","page":"Literature Review","title":"3. Generator start-up optimization","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nW. Sun, C. C. Liu, and L. Zhang, “Optimal generator start-up strategy for bulk power system restoration,” IEEE Trans. Power Syst., vol. 26, no. 3, pp. 1357–1366, 2011. ––––––- ––-\nX. Gu, W. Liu, and C. Sun, “Optimisation for unit restarting sequence considering decreasing trend of unit start-up efficiency after a power system blackout,” IET Gener. Transm. Distrib., vol. 10, no. 16, pp. 4187–4196, 2016. ––––––- ––-\nY. Zhao, Z. Lin, Y. Ding, Y. Liu, L. Sun, and Y. Yan, “A model predictive control based generator start-up optimization strategy for restoration with microgrids as black-start resources,” IEEE Trans. Power Syst., vol. 33, no. 6, pp. 7189–7203, 2018. Motivation: microgrids as black-start resources and address uncertainty; Methood: MPC + scenario reduction using mass transportation problem; no power flow models ––-\nR. Sun, Y. Liu, and L. Wang, “An online generator start-up algorithm for transmission system self-healing based on mcts and sparse autoencoder,” IEEE Trans. Power Syst., vol. 34, no. 3, pp. 2061–2070, 2019. Motivation: the shortcomings of offline restoration plan; Method: Expert system based online generator start-up system ==> Monte Carlo tree search and sparse autoencoder Western Shandong Power Grid of China\nX. Gu, G. Zhou, S. Li, and T. Liu, “Global optimisation model and algorithm for unit restarting sequence considering black-start zone partitioning,” IET Gener. Transm. Distrib., vol. 13, no. 13, pp. 2652–2663, 2019. ––––––- ––-\nL. Sun, W. Liu, C. Y. Chung, M. Ding, R. Bi, and L. Wang, “Improving the restorability of bulk power systems with the implementation of a wf-bess system,” IEEE Trans. Power Syst., vol. 34, no. 3, pp. 2366–2377, 2019. Motivation: adtively dispatch wind and energy storage; Method: define restorability index ==> consider uncertainty and scenario reduction ==> optimal dispatch of wind and energy storage ==> Benders decomposition with restoration as master and dispatch as slave Guangdong power system in China\nL. Sun, Z. Lin, Y. Xu, F. Wen, C. Zhang, and Y. Xue, “Optimal Skeleton-Network Restoration Considering Generator Start-Up Sequence and Load Pickup,” IEEE Trans. Smart Grid, vol. 10, no. 3, pp. 3174–3185, 2019. Motivation: integrate startup and transmission line selection; Method: sequentially solve three problems: generator startup, network building and load pickup IEEE 39-bus; Guangdong power system in China","category":"page"},{"location":"ch4_sec1_literature.html#.-Path-search-1","page":"Literature Review","title":"4. Path search","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nY. Liu and X. Gu, “Skeleton-network reconfiguration based on topological characteristics of scale-free networks and discrete particle swarm optimization,” IEEE Trans. Power Syst., vol. 22, no. 3, pp. 1267–1274, 2007. ––––––- ––-\nC. Wang, V. Vittal, V. S. Kolluri, and S. Mandal, “PTDF-based automatic restoration path selection,” IEEE Trans. Power Syst., vol. 25, no. 3, pp. 1686–1695, 2010. ––––––- ––-\nF. Edström and L. Söder, “On spectral graph theory in power system restoration,” IEEE PES Innov. Smart Grid Technol. Conf. Eur., 2011. ––––––- ––-\nW. Sun and C. C. Liu, “Optimal transmission path search in power system restoration,” Proc. IREP Symp. Bulk Power Syst. Dyn. Control - IX Optim. Secur. Control Emerg. Power Grid, IREP 2013, pp. 0–4, 2013. ––––––- ––-\nY. Xie, K. Song, Q. Wu, and Q. Zhou, “Orthogonal genetic algorithm based power system restoration path optimization,” Int. Trans. Electr. Energy Syst., vol. 28, no. 12, pp. 1–17, 2018. ––––––- ––-\nS. Liao et al., “An improved two-stage optimization for network and load recovery during power system restoration,” Appl. Energy, vol. 249, no. January, pp. 265–275, 2019. ––––––- ––-\nS. Li, X. Gu, G. Zhou, and Y. Li, “Optimisation and comprehensive evaluation of alternative energising paths for power system restoration,” IET Gener. Transm. Distrib., vol. 13, no. 10, pp. 1923–1932, 2019. ––––––- ––-","category":"page"},{"location":"ch4_sec1_literature.html#.-Load-pickup-1","page":"Literature Review","title":"5. Load pickup","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nZ. Qin, Y. Hou, C. C. Liu, S. Liu, and W. Sun, “Coordinating generation and load pickup during load restoration with discrete load increments and reserve constraints,” IET Gener. Transm. Distrib., vol. 9, no. 15, pp. 2437–2446, 2015. ––––––- ––-\nA. Gholami and F. Aminifar, “A Hierarchical Response-Based Approach to the Load Restoration Problem,” IEEE Trans. Smart Grid, vol. 8, no. 4, pp. 1700–1709, 2017. ––––––- ––-\nA. Golshani, W. Sun, and K. Sun, “Real-Time Optimized Load Recovery Considering Frequency Constraints,” IEEE Trans. Power Syst., vol. 34, no. 6, pp. 4204–4215, 2019. ––––––- ––-\nJ. Zhao, H. Wang, Y. Liu, R. Azizipanah-Abarghooee, and V. Terzija, “Utility-oriented online load restoration considering wind power penetration,” IEEE Trans. Sustain. Energy, vol. 10, no. 2, pp. 706–717, 2019. ––––––––––––– ––––\nJ. Zhao, Y. Liu, H. Wang, and Q. Wu, “Receding horizon load restoration for coupled transmission and distribution system considering load-source uncertainty,” Int. J. Electr. Power Energy Syst., vol. 116, no. July 2019, p. 105517, 2020. ––––––––––––– ––––\nJ. Zhao, H. Wang, Q. Wu, N. D. Hatziargyriou, and F. Shen, “Distributed Risk-limiting Load Restoration for Wind Power Penetrated Bulk System,” IEEE Trans. Power Syst., vol. 8950, no. c, pp. 1–1, 2020. ––––––––––––– ––––","category":"page"},{"location":"ch4_sec1_literature.html#Integrated-Methods-1","page":"Literature Review","title":"Integrated Methods","text":"","category":"section"},{"location":"ch4_sec1_literature.html#","page":"Literature Review","title":"Literature Review","text":"Paper Technical Features Test Systems\nQiu, Feng, and Peijie Li. \"An integrated approach for power system restoration planning.\" Proceedings of the IEEE 105, no. 7 (2017): 1234-1252. sequentially integrated method: sectionalization==>optimize generator start-up==>path search==>solution refinement IEEE 30-bus, IEEE 118-bus\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, and J. Tong, “Two-Stage Adaptive Restoration Decision Support System for a Self-Healing Power Grid,” IEEE Trans. Ind. Informatics, vol. 13, no. 6, pp. 2802–2812, 2017. ––––––––––––– ––––\nY. Jiang et al., “Blackstart capability planning for power system restoration,” Int. J. Electr. Power Energy Syst., vol. 86, pp. 127–137, 2017. ––––––––––––– ––––\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, J. Wang, and F. Qiu, “Coordination of Wind Farm and Pumped-Storage Hydro for a Self-Healing Power Grid,” IEEE Trans. Sustain. Energy, vol. 9, no. 4, pp. 1910–1920, 2018. ––––––––––––– ––––\nA. Golshani, W. Sun, Q. Zhou, Q. P. Zheng, and Y. Hou, “Incorporating Wind Energy in Power System Restoration Planning,” IEEE Trans. Smart Grid, vol. 10, no. 1, pp. 16–28, 2019. ––––––––––––– ––––\nW. Liu, J. Zhan, C. Y. Chung, and L. Sun, “Availability Assessment Based Case-Sensitive Power System Restoration Strategy,” IEEE Trans. Power Syst., vol. 35, no. 2, pp. 1432–1445, 2020. ––––––––––––– ––––","category":"page"},{"location":"ch1_sec2_formulations.html#Mathematical-Model-1","page":"Problem Formulations","title":"Mathematical Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Power Flow Model\nNodal Constraint Model\nGenerator Cranking Model\nGenerator Dispatch Model\nLoad Dispatch Model","category":"page"},{"location":"ch1_sec2_formulations.html#Sets,-Parameters-and-Variables-1","page":"Problem Formulations","title":"Sets, Parameters and Variables","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n\nmboxIndices and Sets   \n ijin N mbox - buses \n bin B mbox - branches \n gin G mbox - generators \n lin L mbox - loads \n\nmboxParameters   \n Pcr_g quadforall g in G mbox - generator cranking power power needed for the unit to be normally functional\n Tcr_g quadforall g in G mbox - generator cranking time time needed for the unit to be normally functional\n Krp_g quadforall g in G mbox - generator ramping rate \n\nmboxBinary Variables   \n x_ijt mbox - status of line ij at time t\n y_gt mbox - status of generator g at time t\n u_it mbox - status of bus i at time t\n\nmboxContinuous Variables   \n v_it mbox - voltage of bus i at time t\n a_it mbox - relative angle of bus i at time t\n vl_ijt mbox - supplementary variables for voltage of bus i (connected to bus j) at time t\n vb_it mbox - supplementary variables for voltage of bus i at time t\n al_ijt mbox - supplementary variables for relative angle of bus i (connected to bus j) at time t\n pl_lt mbox - active power of load l at time t\n ql_lt mbox - reactive power of load l at time t\n pg_lt mbox - active power of generator g at time t\n qg_lt mbox - reactive power of generator g at time t\n p_bijt mbox - active power flow of branch b (bus i and j) at time t\n q_bijt mbox - reactive power flow of branch b (bus i and j) at time t\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Power-Flow-Model-1","page":"Problem Formulations","title":"Power Flow Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of branch constraints are implemented in function form_branch.","category":"page"},{"location":"ch1_sec2_formulations.html#AC-power-flow-1","page":"Problem Formulations","title":"AC power flow","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The typical π-circuit line model with an ideal transformer is used to model the standard \"AC\" power flow: (Image: Line model)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The Y-bus can be formulated as follows: (Image: Y bus)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Three representations of AC power flow can be found below: (Image: AC power flow)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Molzahn, Daniel K., and Ian A. Hiskens. \"A survey of relaxations and approximations of the power flow equations.\" Foundations and Trends® in Electric Energy Systems 4, no. 1-2 (2019): 1-221.)","category":"page"},{"location":"ch1_sec2_formulations.html#DC-power-flow-1","page":"Problem Formulations","title":"DC power flow","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The standard \"DC\" approximation to AC power flow linearizes these equations by using the approximations v_i=v_j=1, sinα_ij=α_ij, cosα_ij=1, and b_lg_l=0 yielding:","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\np_ij=B_ijα_ij\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Linearized-AC-power-flow-1","page":"Problem Formulations","title":"Linearized AC power flow","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Expanding the line flows about v_i=v_j=1, α_ij=0 and making small-angle approximations sinα_ij=α_ij and cosα_ij=1 yielding linearized AC power flow","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n p_ijt=G_ii(2v_it-1) + G_ij(v_it + v_jt-1) + B_ijsinα_ij\n q_ijt=-B_ii(2v_it-1) - B_ij(v_it + v_jt-1) + G_ijcosα_ij\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"where voltage and reactive power are retained.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Trodden, Paul A., Waqquas Ahmed Bukhsh, Andreas Grothey, and Ken IM McKinnon. \"Optimization-based islanding of power networks using piecewise linear AC power flow.\" IEEE Transactions on Power Systems 29, no. 3 (2013): 1212-1220.)","category":"page"},{"location":"ch1_sec2_formulations.html#Linearized-AC-power-flow-with-bus-and-line-energization-1","page":"Problem Formulations","title":"Linearized AC power flow with bus and line energization","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Nodal-Constraint-Model-1","page":"Problem Formulations","title":"Nodal Constraint Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of nodal constraints are implemented in function form_nodal.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Voltage Constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_jt - v^min_j(1-x_ijt)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Angle Difference Constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":" beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-a_jt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Generator and Bus Energizing Logics\non-line generator cannot be shut down\nbus should be energized before the connected genertor being on","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Bus Energized Constraints\nbus energized indicating generator energized\non-line buses cannot be shut down","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n v^minu_it leq vb_it leq v^maxu_it \n v_it - v^max(1-u_it) leq vb_it leq v_it - v^min(1-u_it)\n u_gt = y_gt\n u_it geq u_it-1\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Nodal Power Balance Constraint","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n sum_bin ip_bt=sum_gin ipg_gt-sum_lin ipl_lt-Gs(2vb_it-u_it)\n sum_bin iq_bt=sum_gin iqg_gt-sum_lin iql_lt+Bs(2vb_it-u_it)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Generator-Cranking-Model-1","page":"Problem Formulations","title":"Generator Cranking Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of generator cranking constraints are implemented in function form_bs_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The capacity curve for non-black start generator is simplifed and modeled as a piecewise linear function of time shown below.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Image: Capacity curve)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Qiu, Feng, and Peijie Li. \"An integrated approach for power system restoration planning.\" Proceedings of the IEEE 105, no. 7 (2017): 1234-1252.)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Once a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time. \"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"set non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Mathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability. There will be the following scenarios","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"All scenarios can be formulated as follows:","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gTcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Generator-Dispatch-Model-1","page":"Problem Formulations","title":"Generator Dispatch Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations are implemented in function form_gen_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Generator ramping rate constraint","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Black-start unit is determined by the cranking power","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"On-line generators cannot be shut down","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\ny_gt = y_gt+1\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Load-Dispatch-Model-1","page":"Problem Formulations","title":"Load Dispatch Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations are implemented in function form_load_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"restored load cannot exceed its maximum values","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"restored load cannot be shed","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Advanced-Algorithms-1","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#Multi-Resolution-Approach-1","page":"Advanced Algorithms","title":"Multi-Resolution Approach","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We developed a multi-resolution restoration algorithm to accelerate the overall solution time and prepare the software package for large-scale systems. The approach is based on the fact that better solutions can be found with smaller time steps, that is, higher resolution, which results in more complex optimization model. In addition, it is often difficult for the solver to obtain a feasible solution when the time step is small. Therefore, the essence of the algorithm is to hierarchically increase the resolution (that is, decrease the time steps) and guide the search of higher-resolution problem using solutions from lower-resolution solutions. Specifically, generator decision variables at certain time interval will be fixed to either zero or one depending on the result from the previous step. The algorithm is illustrated in Figure 1, where Figure 1 (a) shows the step of the approach and Figure 1 (b) illustrate the fixing rules. (Image: Multi-resolution method)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We verify the method on the black start problem for the IEEE 39-bus system. The computation results are shown in Table 1 with total time equal to 300 minutes. In Scenario 2, the solver cannot reach to convergence after 71 hours. On the other hand, the proposed method can save eight times of the computation time with slightly compromised optimality. This preliminary computation experiments verify the effectiveness of our proposed approach.","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"Scenario Index Gap Resolution (min) Solving Time (sec) With Fixed Constraint All generator dispatchable (min)\n1 1% 50 728 No 251\n2 1% 20 255854 (71h) without convergence No \\\n3 10% 20 8709 No 201\n4 5% 20 327 Generator sequence fixed based on S1 221","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Enhanced-Extended-Term-Event-Driven-Simulation-1","page":"Advanced Algorithms","title":"Enhanced Extended-Term Event-Driven Simulation","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We enhanced the extended-term simulation approach based on semi-analytical simulation (SAS) for restoration studies. And we implemented hybrid simulation switching between the full-dynamic simulation and quasi-steady-state (QSS) simulation. The switch from full-dynamic simulation to QSS simulation is realized directly from SAS coefficients, which is much more efficient than the traditional method that needs extra period of simulation. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We further use SAS to simulate a restoration process of IEEE 39-bus system. The whole process lasts 12,065s and includes 396 events, including bus energization, line energization, line switching, generator cut-in, generator ramping, load cut-in, load ramping events. The QSS simulation covers about 39% of the whole process, and the time saving compared with full-dynamic simulation is about 36%. This verifies that QSS simulation is much faster than the full-dynamic simulation, and the hybrid simulation can significantly enhance efficiency without losing accuracy. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch3_sec1_development_overview.html#Development-Overview-1","page":"Development Overview","title":"Development Overview","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Directory-Tree-1","page":"Development Overview","title":"Directory Tree","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Dependency-1","page":"Development Overview","title":"Dependency","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Documentation-Notes-1","page":"Development Overview","title":"Documentation Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"We use Documenter.jl.","category":"page"},{"location":"ch3_sec1_development_overview.html#Other-Detailed-Notes-1","page":"Development Overview","title":"Other Detailed Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"Code Loading\nPackage Organization","category":"page"},{"location":"index.html#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Welcome to the documentation for EGRIP.jl!","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"EGRIP.jl (Electricity Grid Resilience Improvement Program) is a Julia/MATALB package for power system restoration planning and verification. The objective of this toolkit is to:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Improve the preparedness of power systems for extreme weather conditions\nEnhance the capability of quick recovery from damages (such as partial or complete blackout)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The holistic framework shown below consists of three main modules: nowcasting weather forecasting, simulation and restoration.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simulation module provides predictive outages and damages, and dynamic security assessment for restoration plan to guarantee practicality\nRestoration module provides Multi-time scale (resource allocation and operation) multi-level (bulk power system and distribution level) restoration optimization","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Holistic structure)","category":"page"},{"location":"index.html#Optimization-Core-1","page":"Home","title":"Optimization Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The optimization core is designed in a modularize and hierarchical manner to facilitate future algorithm development, multi-purpose usage as well as reduce the coding overhead. It consists of three levels, that is, fundamental function level, ordinary problem level and advanced solution level.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The fundamental function level is to provide basic optimization formulations. Currently it consists of generator dispatch model, generator cranking model, controllable load dispatch model, linearized AC power flow model and AC power flow model as well as data I/O.\nThe ordinary problem level formulates different problems using appropriate functions from both fundamental and its own levels. Currently there are three ordinary problems, that is, load restoration problem, system black-start problem and AC power flow feasibility checking problem. The load restoration problem is to maximize served load under a energized topology. The system black-start problem is to simultaneously energize the system and restore load service through black-start units.\nThe advanced solution level is to either speed up the computation or accommodate new capabilities using both state-of-the-art optimization algorithm and power system domain knowledge. Currently it consists of the multi-resolution restoration algorithm and meta heuristic enhancement. The multi-resolution restoration algorithm is to accelerate the overall solution time by guiding the search of higher-resolution problem using solutions from lower-resolution solutions. The meta heuristic enhancement uses power system domain knowledge and to add additional physical constraints and empirical rules to speed up the computation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Simulation-Core-1","page":"Home","title":"Simulation Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The simulation core is used for the resilience assessment of system under possible extreme events and in the restoration process. The simulation core utilizes the simulation tool based on semi-analytical solutions (SAS). The SAS has enhanced numerical robustness and computational efficiency, which enables the analysis of very complex dynamic processes in large-scale power systems. The SAS-based simulation tool has the following major features:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Flexible customization of event sequences. Users can conveniently define the event sequences through an event list file. The simulation tool supports various types of events, such as adding/tripping components, adding/clearing faults, ramping of load/ generation. The event scheduler dispatches the simulation workflow to simulate the event sequence.\nRich model library. The simulation tool supports steady-state analysis and dynamic simulation. The model library includes dynamic models of synchronous generators, controllers (AVR and turbine governor), static load (e.g. ZIP) and induction motor load, and AGC model. And the model library is still expanding. The simulation tool admits widely supported PSAT data format.\nEnhanced robustness. The SAS as a high-order advanced computational approach with analytical form, has guaranteed numerical convergence to existing solution. Therefore, the SAS users are worry-free of non-convergence issues, and the simulation tool has good capability of performing very complex power system resilience analysis tasks.\nEnhanced efficiency with steady-state & dynamic hybrid simulation. The simulator automatically switches between full-dynamic simulation (where fast transients are significant) and quasi-steady-state (QSS) simulation (where the transients decay and approximately enters steady-state). The hybrid simulation scheme significantly saves computation time compared with the full-dynamic simulation, typically by 30%-70% depending on studied cases.\nFriendly output and visualization functions. The SAS-based simulation tool has a log system that enables printing and recording different levels of events in simulation. After simulation, users can conveniently plot the trajectories of various system states through a specially designed plotting function.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Installation\nMathematical Model\nAdvanced Algorithms\nRestoration Planning and Verification Workflow","category":"page"},{"location":"index.html#Library-1","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Public Library\nInternal Library","category":"page"},{"location":"index.html#Developer-1","page":"Home","title":"Developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Development Overview\nCode Loading\nPackage Organization","category":"page"},{"location":"index.html#Research-1","page":"Home","title":"Research","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Literature Review\nBenchmark Testing","category":"page"}]
}
