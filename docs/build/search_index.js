var documenterSearchIndex = {"docs":
[{"location":"formulations/#The-PowerModels-Mathematical-Model-1","page":"Problem Formulations","title":"The PowerModels Mathematical Model","text":"","category":"section"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"As PowerModels implements a variety of power network optimization problems, the implementation is the best reference for precise mathematical formulations.  This section provides a complex number based mathematical specification for a prototypical AC Optimal Power Flow problem, to provide an overview of the typical mathematical models in PowerModels.","category":"page"},{"location":"formulations/#Sets-and-Parameters-1","page":"Problem Formulations","title":"Sets and Parameters","text":"","category":"section"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower.  These generalizations make it possible for PowerModels to more accurately capture industrial transmission network datasets.  The core generalizations are,","category":"page"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"Support for multiple load (S^d_k) and shunt (Y^s_k) components on each bus i\nLine charging that supports a conductance and asymmetrical values (Y^c_ij Y^c_ji)","category":"page"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign","category":"page"},{"location":"formulations/#AC-Optimal-Power-Flow-1","page":"Problem Formulations","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"A complete mathematical model is as follows,","category":"page"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G mbox - generator complex power dispatch labelvar_generation\n V_i  forall iin N labelvar_voltage mbox - bus complex voltage\n S_ij  forall (ij) in E cup E^R  labelvar_complex_power mbox - branch complex power flow\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k labeleq_objective\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R labeleq_ref_bus\n S^gl_k leq S^g_k leq S^gu_k  forall k in G  labeleq_gen_bounds\n v^l_i leq V_i leq v^u_i  forall i in N labeleq_voltage_bounds\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N labeleq_kcl_shunt \n S_ij = left( Y_ij + Y^c_ijright)^* fracV_i^2T_ij^2 - Y^*_ij fracV_i V^*_jT_ij  forall (ij)in E labeleq_power_from\n S_ji = left( Y_ij + Y^c_ji right)^* V_j^2 - Y^*_ij fracV^*_i V_jT^*_ij  forall (ij)in E labeleq_power_to\n S_ij leq s^u_ij  forall (ij) in E cup E^R labeleq_thermal_limit\n I_ij leq i^u_ij  forall (ij) in E cup E^R labeleq_current_limit\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E labeleq_angle_difference\n\nendalign","category":"page"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"Note that for clarity of this presentation some model variants that PowerModels supports have been omitted (e.g. piecewise linear cost functions and HVDC lines).  Details about these variants is available in the Matpower documentation.","category":"page"},{"location":"formulations/#Mapping-to-function-names-1","page":"Problem Formulations","title":"Mapping to function names","text":"","category":"section"},{"location":"formulations/#","page":"Problem Formulations","title":"Problem Formulations","text":"Eq. eqrefvar_generation - variablegenpower\nEq. eqrefvar_voltage - variablebusvoltage\nEq. eqrefvar_complex_power - variablebranchpower\nEq. eqrefeq_objective -\nEq. eqrefeq_ref_bus -\nEq. eqrefeq_gen_bounds -\nEq. eqrefeq_voltage_bounds -\nEq. eqrefeq_kcl_shunt -\nEq. eqrefeq_power_from -\nEq. eqrefeq_power_to -\nEq. eqrefeq_thermal_limit -\nEq. eqrefeq_current_limit -\nEq. eqrefeq_angle_difference -","category":"page"},{"location":"quickguide/#Quick-Start-Guide-1","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Once PowerModels is installed, Ipopt is installed, and a network data file (e.g. \"case3.m\" or \"case3.raw\") has been acquired, an AC Optimal Power Flow can be executed with,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"using PowerModels\nusing Ipopt\n\nrun_ac_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Similarly, a DC Optimal Power Flow can be executed with","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"run_dc_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"PTI .raw files in the PSS(R)E v33 specification can be run similarly, e.g. in the case of an AC Optimal Power Flow","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"run_ac_opf(\"case3.raw\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#Getting-Results-1","page":"Getting Started","title":"Getting Results","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The run commands in PowerModels return detailed results data in the form of a dictionary. Results dictionaries from either Matpower .m or PTI .raw files will be identical in format. This dictionary can be saved for further processing as follows,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"result = run_ac_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"For example, the algorithm's runtime and final objective value can be accessed with,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"result[\"solve_time\"]\nresult[\"objective\"]","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The \"solution\" field contains detailed information about the solution produced by the run method. For example, the following dictionary comprehension can be used to inspect the bus voltage angles in the solution,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Dict(name => data[\"va\"] for (name, data) in result[\"solution\"][\"bus\"])","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The print_summary(result[\"solution\"]) function can be used show an table-like overview of the solution data.  For more information about PowerModels result data see the PowerModels Result Data Format section.","category":"page"},{"location":"quickguide/#Accessing-Different-Formulations-1","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The function run_ac_opf and run_dc_opf are shorthands for a more general formulation-independent OPF execution, run_opf. For example, run_ac_opf is equivalent to,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"run_opf(\"matpower/case3.m\", ACPPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"where \"ACPPowerModel\" indicates an AC formulation in polar coordinates.  This more generic run_opf() allows one to solve an OPF problem with any power network formulation implemented in PowerModels.  For example, an SOC Optimal Power Flow can be run with,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"run_opf(\"matpower/case3.m\", SOCWRPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Formulation Details provides a list of available formulations.","category":"page"},{"location":"quickguide/#Modifying-Network-Data-1","page":"Getting Started","title":"Modifying Network Data","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates one way to perform multiple PowerModels solves while modifing the network data in Julia,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\nrun_opf(network_data, ACPPowerModel, with_optimizer(Ipopt.Optimizer))\n\nnetwork_data[\"load\"][\"3\"][\"pd\"] = 0.0\nnetwork_data[\"load\"][\"3\"][\"qd\"] = 0.0\n\nrun_opf(network_data, ACPPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Network data parsed from PTI .raw files supports data extensions, i.e. data fields that are within the PSS(R)E specification, but not used by PowerModels for calculation. This can be achieved by","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"pti/case3.raw\"; import_all=true)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"This network data can be modified in the same way as the previous Matpower .m file example. For additional details about the network data, see the PowerModels Network Data Format section.","category":"page"},{"location":"quickguide/#Inspecting-AC-and-DC-branch-flow-results-1","page":"Getting Started","title":"Inspecting AC and DC branch flow results","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The flow AC and DC branch results are written to the result by default. The following can be used to inspect the flow results:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"result = run_opf(\"matpower/case3_dc.m\", ACPPowerModel, with_optimizer(Ipopt.Optimizer))\nresult[\"solution\"][\"dcline\"][\"1\"]\nresult[\"solution\"][\"branch\"][\"2\"]","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The losses of an AC or DC branch can be derived:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"loss_ac =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"branch\"])\nloss_dc =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"dcline\"])","category":"page"},{"location":"quickguide/#Building-PowerModels-from-Network-Data-Dictionaries-1","page":"Getting Started","title":"Building PowerModels from Network Data Dictionaries","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates how to break a run_opf call into separate model building and solving steps.  This allows inspection of the JuMP model created by PowerModels for the AC-OPF problem,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"pm = instantiate_model(\"matpower/case3.m\", ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Alternatively, you can further break it up by parsing a file into a network data dictionary, before passing it on to instantiate_model() like so,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\npm = instantiate_model(network_data, ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"CurrentModule = EGRIP","category":"page"},{"location":"library/#Formulation-Function-1","page":"Library","title":"Formulation Function","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"use @docs block to splice the docstrings","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"solve_restoration","category":"page"},{"location":"library/#EGRIP.solve_restoration","page":"Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [EGRIP]\nPages   = [\"bs_initial_step.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"library/#EGRIP.solve_restoration-NTuple{5,Any}","page":"Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem\n\n\n\n\n\n","category":"method"},{"location":"library/#I/O-Function-1","page":"Library","title":"I/O Function","text":"","category":"section"},{"location":"#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"EGRIP.jl is a Julia/JuMP package for restoration.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"}]
}
