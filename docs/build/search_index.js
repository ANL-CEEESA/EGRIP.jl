var documenterSearchIndex = {"docs":
[{"location":"formulations.html#The-PowerModels-Mathematical-Model-1","page":"Problem Formulations","title":"The PowerModels Mathematical Model","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"As PowerModels implements a variety of power network optimization problems, the implementation is the best reference for precise mathematical formulations.  This section provides a complex number based mathematical specification for a prototypical AC Optimal Power Flow problem, to provide an overview of the typical mathematical models in PowerModels.","category":"page"},{"location":"formulations.html#Sets-and-Parameters-1","page":"Problem Formulations","title":"Sets and Parameters","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower.  These generalizations make it possible for PowerModels to more accurately capture industrial transmission network datasets.  The core generalizations are,","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Support for multiple load (S^d_k) and shunt (Y^s_k) components on each bus i\nLine charging that supports a conductance and asymmetrical values (Y^c_ij Y^c_ji)","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign","category":"page"},{"location":"formulations.html#AC-Optimal-Power-Flow-1","page":"Problem Formulations","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"A complete mathematical model is as follows,","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G mbox - generator complex power dispatch labelvar_generation\n V_i  forall iin N labelvar_voltage mbox - bus complex voltage\n S_ij  forall (ij) in E cup E^R  labelvar_complex_power mbox - branch complex power flow\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k labeleq_objective\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R labeleq_ref_bus\n S^gl_k leq S^g_k leq S^gu_k  forall k in G  labeleq_gen_bounds\n v^l_i leq V_i leq v^u_i  forall i in N labeleq_voltage_bounds\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N labeleq_kcl_shunt \n S_ij = left( Y_ij + Y^c_ijright)^* fracV_i^2T_ij^2 - Y^*_ij fracV_i V^*_jT_ij  forall (ij)in E labeleq_power_from\n S_ji = left( Y_ij + Y^c_ji right)^* V_j^2 - Y^*_ij fracV^*_i V_jT^*_ij  forall (ij)in E labeleq_power_to\n S_ij leq s^u_ij  forall (ij) in E cup E^R labeleq_thermal_limit\n I_ij leq i^u_ij  forall (ij) in E cup E^R labeleq_current_limit\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E labeleq_angle_difference\n\nendalign","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Note that for clarity of this presentation some model variants that PowerModels supports have been omitted (e.g. piecewise linear cost functions and HVDC lines).  Details about these variants is available in the Matpower documentation.","category":"page"},{"location":"formulations.html#Mapping-to-function-names-1","page":"Problem Formulations","title":"Mapping to function names","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Eq. eqrefvar_generation - variablegenpower\nEq. eqrefvar_voltage - variablebusvoltage\nEq. eqrefvar_complex_power - variablebranchpower\nEq. eqrefeq_objective -\nEq. eqrefeq_ref_bus -\nEq. eqrefeq_gen_bounds -\nEq. eqrefeq_voltage_bounds -\nEq. eqrefeq_kcl_shunt -\nEq. eqrefeq_power_from -\nEq. eqrefeq_power_to -\nEq. eqrefeq_thermal_limit -\nEq. eqrefeq_current_limit -\nEq. eqrefeq_angle_difference -","category":"page"},{"location":"quickguide.html#Quick-Start-Guide-1","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Once PowerModels is installed, Ipopt is installed, and a network data file (e.g. \"case3.m\" or \"case3.raw\") has been acquired, an AC Optimal Power Flow can be executed with,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"using PowerModels\nusing Ipopt\n\nrun_ac_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Similarly, a DC Optimal Power Flow can be executed with","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"run_dc_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"PTI .raw files in the PSS(R)E v33 specification can be run similarly, e.g. in the case of an AC Optimal Power Flow","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"run_ac_opf(\"case3.raw\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#Getting-Results-1","page":"Getting Started","title":"Getting Results","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The run commands in PowerModels return detailed results data in the form of a dictionary. Results dictionaries from either Matpower .m or PTI .raw files will be identical in format. This dictionary can be saved for further processing as follows,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"result = run_ac_opf(\"matpower/case3.m\", with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"For example, the algorithm's runtime and final objective value can be accessed with,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"result[\"solve_time\"]\nresult[\"objective\"]","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The \"solution\" field contains detailed information about the solution produced by the run method. For example, the following dictionary comprehension can be used to inspect the bus voltage angles in the solution,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Dict(name => data[\"va\"] for (name, data) in result[\"solution\"][\"bus\"])","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The print_summary(result[\"solution\"]) function can be used show an table-like overview of the solution data.  For more information about PowerModels result data see the Formulation Function section.","category":"page"},{"location":"quickguide.html#Accessing-Different-Formulations-1","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The function run_ac_opf and run_dc_opf are shorthands for a more general formulation-independent OPF execution, run_opf. For example, run_ac_opf is equivalent to,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"run_opf(\"matpower/case3.m\", ACPPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"where \"ACPPowerModel\" indicates an AC formulation in polar coordinates.  This more generic run_opf() allows one to solve an OPF problem with any power network formulation implemented in PowerModels.  For example, an SOC Optimal Power Flow can be run with,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"run_opf(\"matpower/case3.m\", SOCWRPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Formulation Function provides a list of available formulations.","category":"page"},{"location":"quickguide.html#Modifying-Network-Data-1","page":"Getting Started","title":"Modifying Network Data","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates one way to perform multiple PowerModels solves while modifing the network data in Julia,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\nrun_opf(network_data, ACPPowerModel, with_optimizer(Ipopt.Optimizer))\n\nnetwork_data[\"load\"][\"3\"][\"pd\"] = 0.0\nnetwork_data[\"load\"][\"3\"][\"qd\"] = 0.0\n\nrun_opf(network_data, ACPPowerModel, with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Network data parsed from PTI .raw files supports data extensions, i.e. data fields that are within the PSS(R)E specification, but not used by PowerModels for calculation. This can be achieved by","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"pti/case3.raw\"; import_all=true)","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"This network data can be modified in the same way as the previous Matpower .m file example. For additional details about the network data, see the Formulation Function section.","category":"page"},{"location":"quickguide.html#Inspecting-AC-and-DC-branch-flow-results-1","page":"Getting Started","title":"Inspecting AC and DC branch flow results","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The flow AC and DC branch results are written to the result by default. The following can be used to inspect the flow results:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"result = run_opf(\"matpower/case3_dc.m\", ACPPowerModel, with_optimizer(Ipopt.Optimizer))\nresult[\"solution\"][\"dcline\"][\"1\"]\nresult[\"solution\"][\"branch\"][\"2\"]","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The losses of an AC or DC branch can be derived:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"loss_ac =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"branch\"])\nloss_dc =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"dcline\"])","category":"page"},{"location":"quickguide.html#Building-PowerModels-from-Network-Data-Dictionaries-1","page":"Getting Started","title":"Building PowerModels from Network Data Dictionaries","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates how to break a run_opf call into separate model building and solving steps.  This allows inspection of the JuMP model created by PowerModels for the AC-OPF problem,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"pm = instantiate_model(\"matpower/case3.m\", ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Alternatively, you can further break it up by parsing a file into a network data dictionary, before passing it on to instantiate_model() like so,","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\npm = instantiate_model(network_data, ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"library_public.html#Public-Library-1","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"library_public.html#","page":"Public Library","title":"Public Library","text":"CurrentModule = EGRIP","category":"page"},{"location":"library_public.html#Formulation-Function-1","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"library_public.html#","page":"Public Library","title":"Public Library","text":"use @docs block to splice the docstrings","category":"page"},{"location":"library_public.html#","page":"Public Library","title":"Public Library","text":"solve_restoration","category":"page"},{"location":"library_public.html#EGRIP.solve_restoration","page":"Public Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#Internal-Library-1","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"library_internal.html#Formulation-Function-1","page":"Internal Library","title":"Formulation Function","text":"","category":"section"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"bs_initial_step.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"library_internal.html#EGRIP.solve_restoration-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#I/O-Function-1","page":"Internal Library","title":"I/O Function","text":"","category":"section"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"parser.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"library_internal.html#EGRIP._check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP._check_conductors","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._check_cost_function-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP._check_cost_function","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._make_mixed_units-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_mixed_units","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._make_per_unit-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_per_unit","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._rescale_cost_model-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._rescale_cost_model","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._simplify_pwl_cost","page":"Internal Library","title":"EGRIP._simplify_pwl_cost","text":"checks the slope of each segment in a pwl function, simplifies the function if the slope changes is below a tolerance\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#EGRIP.add_dcline_costs-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.add_dcline_costs","text":"adds dcline costs, if gen costs exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.add_line_delimiter-Tuple{AbstractString,Any,Any}","page":"Internal Library","title":"EGRIP.add_line_delimiter","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.apply_func-Tuple{Dict{String,Any},String,Any}","page":"Internal Library","title":"EGRIP.apply_func","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.arrays_to_dicts!-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.arrays_to_dicts!","text":"turns top level arrays into dicts\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_branch_directions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_directions","text":"checks that all parallel branches have the same orientation\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_branch_loops-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_loops","text":"checks that all branches connect two distinct buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_bus_types-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_bus_types","text":"checks bus types are consistent with generator connections, if not, fixes them\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_conductors","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_connectivity-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_connectivity","text":"checks that all buses are unique and other components link to valid buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_cost_functions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_cost_functions","text":"throws warnings if cost functions are malformed\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_current_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_current_limits","text":"checks that each branch has a reasonable current rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_dcline_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_dcline_limits","text":"checks that parameters for dc lines are reasonable\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_keys-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_keys","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_network_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_network_data","text":"Runs various data quality checks on a PowerModels data dictionary. Applies modifications in some cases.  Reports modified component ids.\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_storage_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_storage_parameters","text":"checks that each storage unit has a reasonable parameters\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_thermal_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_thermal_limits","text":"checks that each branch has a reasonable thermal rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_transformer_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_transformer_parameters","text":"checks that each branch has a reasonable transformer parameters this is important because setting tap == 0.0 leads to NaN computations, which are hard to debug\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_type-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_type","text":"Checks if the given value is of a given type, if not tries to make it that type\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_voltage_angle_differences","page":"Internal Library","title":"EGRIP.check_voltage_angle_differences","text":"checks that voltage angle differences are within 90 deg., if not tightens\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#EGRIP.check_voltage_setpoints-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_voltage_setpoints","text":"throws warnings if generator and dc line voltage setpoints are not consistent with the bus voltage setpoint\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.make_mixed_units-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_mixed_units","text":"Transforms network data into mixed-units (inverse of per-unit)\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.make_per_unit-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_per_unit","text":"Transforms network data into per-unit\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.matpower_to_powermodels-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.matpower_to_powermodels","text":"Converts a Matpower dict into a PowerModels dict\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_bus_name_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_bus_name_data","text":"merges bus name data into buses, if names exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_generator_cost_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generator_cost_data","text":"merges generator cost functions into generator data, if costs exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_generic_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generic_data","text":"merges Matpower tables based on the table extension syntax\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp2pm_branch-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_branch","text":"sets all branch transformer taps to 1.0, to simplify branch models\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp2pm_dcline-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_dcline","text":"adds pmin and pmax values at to and from buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp_cost_data-Tuple{Any}","page":"Internal Library","title":"EGRIP.mp_cost_data","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_cells-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_cells","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_data-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_data","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_matrix-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_matrix","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_file-Tuple{IO}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_file-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_string-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_string","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_mfile-Tuple{Union{IO, String}}","page":"Internal Library","title":"EGRIP.parse_mfile","text":"Parses the matpower data from either a filename or an IO object\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.row_to_dict-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.row_to_dict","text":"takes a row from a matrix and assigns the values names\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.simplify_cost_terms-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.simplify_cost_terms","text":"trims zeros from higher order cost terms\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.split_line-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.split_line","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.split_loads_shunts-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.split_loads_shunts","text":"splitloadsshunts(data) Seperates Loads and Shunts in data under separate \"load\" and \"shunt\" keys in the PowerModels data format. Includes references to originating bus via \"loadbus\" and \"shuntbus\" keys, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.type_array-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Internal Library","title":"EGRIP.type_array","text":"Attempts to determine the type of an array of strings extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.type_value-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.type_value","text":"Attempts to determine the type of a string extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"index.html#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"EGRIP.jl is a Julia/JuMP package for restoration.","category":"page"},{"location":"index.html#Installation-1","page":"Home","title":"Installation","text":"","category":"section"}]
}
