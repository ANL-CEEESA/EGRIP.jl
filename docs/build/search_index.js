var documenterSearchIndex = {"docs":
[{"location":"formulations.html#The-PowerModels-Mathematical-Model-1","page":"Problem Formulations","title":"The PowerModels Mathematical Model","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"As PowerModels implements a variety of power network optimization problems, the implementation is the best reference for precise mathematical formulations.  This section provides a complex number based mathematical specification for a prototypical AC Optimal Power Flow problem, to provide an overview of the typical mathematical models in PowerModels.","category":"page"},{"location":"formulations.html#Sets-and-Parameters-1","page":"Problem Formulations","title":"Sets and Parameters","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower.  These generalizations make it possible for PowerModels to more accurately capture industrial transmission network datasets.  The core generalizations are,","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Support for multiple load (S^d_k) and shunt (Y^s_k) components on each bus i\nLine charging that supports a conductance and asymmetrical values (Y^c_ij Y^c_ji)","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign","category":"page"},{"location":"formulations.html#AC-Optimal-Power-Flow-1","page":"Problem Formulations","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"A complete mathematical model is as follows,","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G mbox - generator complex power dispatch labelvar_generation\n V_i  forall iin N labelvar_voltage mbox - bus complex voltage\n S_ij  forall (ij) in E cup E^R  labelvar_complex_power mbox - branch complex power flow\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k labeleq_objective\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R labeleq_ref_bus\n S^gl_k leq S^g_k leq S^gu_k  forall k in G  labeleq_gen_bounds\n v^l_i leq V_i leq v^u_i  forall i in N labeleq_voltage_bounds\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N labeleq_kcl_shunt \n S_ij = left( Y_ij + Y^c_ijright)^* fracV_i^2T_ij^2 - Y^*_ij fracV_i V^*_jT_ij  forall (ij)in E labeleq_power_from\n S_ji = left( Y_ij + Y^c_ji right)^* V_j^2 - Y^*_ij fracV^*_i V_jT^*_ij  forall (ij)in E labeleq_power_to\n S_ij leq s^u_ij  forall (ij) in E cup E^R labeleq_thermal_limit\n I_ij leq i^u_ij  forall (ij) in E cup E^R labeleq_current_limit\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E labeleq_angle_difference\n\nendalign","category":"page"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Note that for clarity of this presentation some model variants that PowerModels supports have been omitted (e.g. piecewise linear cost functions and HVDC lines).  Details about these variants is available in the Matpower documentation.","category":"page"},{"location":"formulations.html#Mapping-to-function-names-1","page":"Problem Formulations","title":"Mapping to function names","text":"","category":"section"},{"location":"formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Eq. eqrefvar_generation - variablegenpower\nEq. eqrefvar_voltage - variablebusvoltage\nEq. eqrefvar_complex_power - variablebranchpower\nEq. eqrefeq_objective -\nEq. eqrefeq_ref_bus -\nEq. eqrefeq_gen_bounds -\nEq. eqrefeq_voltage_bounds -\nEq. eqrefeq_kcl_shunt -\nEq. eqrefeq_power_from -\nEq. eqrefeq_power_to -\nEq. eqrefeq_thermal_limit -\nEq. eqrefeq_current_limit -\nEq. eqrefeq_angle_difference -","category":"page"},{"location":"quickguide.html#Quick-Start-Guide-1","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide.html#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"For now since EGRIP.jl has not been registered, we need to load the package locally by putting the following code at the beginning of your test script:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")","category":"page"},{"location":"quickguide.html#Solving-Problem-1","page":"Getting Started","title":"Solving Problem","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"We can use the package by declaring it:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"using EGRIP","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"First, we need to tell the package where our problem data is:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"dir_case_network = \"/Users/whoiszyc/Github/EGRIP.jl/src/cases/ieee_39bus/case39.m\"\ndir_case_blackstart = \"/Users/whoiszyc/Github/EGRIP.jl/src/cases/ieee_39bus/BS_generator.csv\"\ndir_case_result = \"/Users/whoiszyc/Github/EGRIP.jl/src/cases/ieee_39bus/results/\"","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Then, we define the restoration duration and time steps:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"t_final = 500\nt_step = 250","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Once everything is ready, we can call solve_restoration function to solve the problem:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"solve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step)","category":"page"},{"location":"quickguide.html#Getting-Results-1","page":"Getting Started","title":"Getting Results","text":"","category":"section"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Part of the results will be printed once the algorithm terminates.","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Line energization:\nstage 1.0:\nstage 2.0:\n\nGenerator energization:\nstage 1.0: 39\nstage 2.0:\n\nBus energization:\nstage 1.0: 39\nstage 2.0:","category":"page"},{"location":"quickguide.html#","page":"Getting Started","title":"Getting Started","text":"Detailed results will be stored in results folder under the directory containing the case file.","category":"page"},{"location":"development_notes.html#Code-Loading-1","page":"Development Notes","title":"Code Loading","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"The current confusion is on how Julia load packages and modules that are not registered through Pkg.","category":"page"},{"location":"development_notes.html#Working-Directory-1","page":"Development Notes","title":"Working Directory","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"The working directory, which can be obtained by pwd(), has to be the one containing our packages for things to be loaded correctly.\nWe can add the command cd(@__DIR__) at the beginning of our code to navigate the directory to where our code is running.","category":"page"},{"location":"development_notes.html#Package-Loading-1","page":"Development Notes","title":"Package Loading","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Assmue we would like to use our developed but unregistered package EGRIP.jl at a Julia file named testrun.jl. There are two ways to load EGRIP.jl.","category":"page"},{"location":"development_notes.html#Include-the-package-and-corresponding-modules-1","page":"Development Notes","title":"Include the package and corresponding modules","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"We can include the main jl file of the package at the top of testrun.jl:","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"cd(@__DIR__) # navigate to correct working directory containing `testrun.jl`\ninclude(\"path to the source code from current working directory/src/EGRIP.jl\")","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Then, we can use the package through relative path import of the main module since it cannot be identified by Julia Environment:","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"using .EGRIP # It tells Julia to find the module around the current working directory instead of Julia Environment","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Due to the similar reason, other modules in the package cannot be identified by Julia Environment. When module_a in file_module_a.jl needs to use a function fun_b from module_b in file_module_b.jl, we need to do the following at the beginning of file_module_a.jl (assmue file_module_a.jl and file_module_b.jl are in the same directory):","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"include(\"file_module_b.jl\")\nusing .module_b","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Then, if fun_b has been exported, we can directly access it. Otherwise. we need to use module_b.fun_b. This is not very convenient.","category":"page"},{"location":"development_notes.html#Add-source-code-directory-into-Julia-Environment-1","page":"Development Notes","title":"Add source code directory into Julia Environment","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"We can make source directory accessible through Julia's LOAD_PATH. We can add the following line at the top of testrun.jl:","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"cd(@__DIR__) # navigate to correct working directory `testrun.jl`\npush!(LOAD_PATH,\"path to the source code from current working directory/src/\")","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Then, we can use the package through absolute path import of the main module since it can be identified by Julia Environment:","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"using EGRIP # It tells Julia to find the module in Julia Environment LOAD_PATH","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"In addition, all other modules can be used in the same way.","category":"page"},{"location":"development_notes.html#Discussion-on-include-1","page":"Development Notes","title":"Discussion on include","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Julia’s include is a function, not a simple input redirector (as in C, Fortran, or Matlab).\nEvaluate the contents of a source file in the current context. “The current context” means the global scope of the current module when the evaluation takes place.\nThis function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\nInclude works in the dynamically-current module, not the lexically-current one.\nIt is really a load-time function, not a run-time one.","category":"page"},{"location":"development_notes.html#Package-Organization-1","page":"Development Notes","title":"Package Organization","text":"","category":"section"},{"location":"development_notes.html#Option-1-1","page":"Development Notes","title":"Option 1","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"We could build one main module called EGRIP and several submodules. In this way, we will declare certain submodule to access its function in another module once the source code is loaded into LOAD_PATH. For example: EGRIP/src/ ––––-EGRIP.jl","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"              module EGRIP\n                include(\"power_flow.jl\")\n                include(\"load_restoration.jl\")\n                using PowerFlow\n                using LoadRestoration\n                function fun_bs()\n                  fun_pf()\n                  fun_lr()\n                end\n                export fun_bs\n              end\n              ```\n---------`power_flow.jl`\n              ```Julia\n              module PowerFlow\n              export func_pf\n                function func_pf()\n                end\n              end\n                ```\n---------`load_restoration.jl`\n            ```Julia\n            module LoadRestoration\n            using PowerFlow\n            export func_lr\n              function func_lr()\n                func_pf()\n              end\n            end\n              ```\n\nThen, in a testing script, we can use the package by","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Julia using EGRIP fun_bs()","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"In addition, we can use the module independently from `EGRIP`","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"Julia using PowerFlow fun_pf() ```","category":"page"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"A different but not good way to do include file. This is suggested to do the include in the main module. And once it is loaded to LOAD_PATH, every included script is accessible. EGRIP/src/ ––––-EGRIP.jl               Julia               module EGRIP                 include(\"load_restoration.jl\")                 using PowerFlow                 using LoadRestoration                 function fun_bs()                   fun_pf()                   fun_lr()                 end                 export fun_bs               end ––––-power_flow.jl               Julia               module PowerFlow               export func_pf                 function func_pf()                 end               end ––––-load_restoration.jl             Julia             module LoadRestoration             include(\"power_flow.jl\")             using PowerFlow             export func_lr               function func_lr()                 func_pf()               end             end","category":"page"},{"location":"development_notes.html#Option-2-1","page":"Development Notes","title":"Option 2","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"We just build one main module EGRIP. The rest functionalities are implemented by functions in different scripts. Then, we just need to include the scripts in the main module. Once the main module is loaded into LOAD_PATH, we can these functions freely between different scripts without further declaration. Some Julia packages like PowerModels.jl are organized in this way. Take an example: EGRIP/src/ ––––-EGRIP.jl               Julia               module EGRIP                 include(\"power_flow.jl\")                 include(\"load_restoration.jl\")                 function fun_bs()                   fun_pf()                   fun_lr()                 end                 export fun_bs               end ––––-power_flow.jl               Julia               function func_pf()               end ––––-load_restoration.jl             Julia             function func_lr()                 func_pf()             end","category":"page"},{"location":"development_notes.html#Documentation-1","page":"Development Notes","title":"Documentation","text":"","category":"section"},{"location":"development_notes.html#","page":"Development Notes","title":"Development Notes","text":"We use Documenter.jl.","category":"page"},{"location":"library_public.html#Public-Library-1","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"library_public.html#Formulation-Function-1","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"library_public.html#","page":"Public Library","title":"Public Library","text":"use @docs block to splice the docstrings","category":"page"},{"location":"library_public.html#","page":"Public Library","title":"Public Library","text":"solve_restoration","category":"page"},{"location":"library_public.html#EGRIP.solve_restoration","page":"Public Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#Internal-Library-1","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"library_internal.html#Formulation-Function-1","page":"Internal Library","title":"Formulation Function","text":"","category":"section"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"bs_initial_step.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"library_internal.html#EGRIP.solve_restoration-NTuple{5,Any}","page":"Internal Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#I/O-Function-1","page":"Internal Library","title":"I/O Function","text":"","category":"section"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"parser.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"library_internal.html#EGRIP._check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP._check_conductors","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._check_cost_function-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP._check_cost_function","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._make_mixed_units-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_mixed_units","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._make_per_unit-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_per_unit","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._rescale_cost_model-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._rescale_cost_model","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP._simplify_pwl_cost","page":"Internal Library","title":"EGRIP._simplify_pwl_cost","text":"checks the slope of each segment in a pwl function, simplifies the function if the slope changes is below a tolerance\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#EGRIP.add_dcline_costs-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.add_dcline_costs","text":"adds dcline costs, if gen costs exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.add_line_delimiter-Tuple{AbstractString,Any,Any}","page":"Internal Library","title":"EGRIP.add_line_delimiter","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.apply_func-Tuple{Dict{String,Any},String,Any}","page":"Internal Library","title":"EGRIP.apply_func","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.arrays_to_dicts!-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.arrays_to_dicts!","text":"turns top level arrays into dicts\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_branch_directions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_directions","text":"checks that all parallel branches have the same orientation\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_branch_loops-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_loops","text":"checks that all branches connect two distinct buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_bus_types-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_bus_types","text":"checks bus types are consistent with generator connections, if not, fixes them\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_conductors","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_connectivity-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_connectivity","text":"checks that all buses are unique and other components link to valid buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_cost_functions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_cost_functions","text":"throws warnings if cost functions are malformed\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_current_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_current_limits","text":"checks that each branch has a reasonable current rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_dcline_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_dcline_limits","text":"checks that parameters for dc lines are reasonable\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_keys-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_keys","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_network_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_network_data","text":"Runs various data quality checks on a PowerModels data dictionary. Applies modifications in some cases.  Reports modified component ids.\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_storage_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_storage_parameters","text":"checks that each storage unit has a reasonable parameters\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_thermal_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_thermal_limits","text":"checks that each branch has a reasonable thermal rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_transformer_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_transformer_parameters","text":"checks that each branch has a reasonable transformer parameters this is important because setting tap == 0.0 leads to NaN computations, which are hard to debug\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_type-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_type","text":"Checks if the given value is of a given type, if not tries to make it that type\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.check_voltage_angle_differences","page":"Internal Library","title":"EGRIP.check_voltage_angle_differences","text":"checks that voltage angle differences are within 90 deg., if not tightens\n\n\n\n\n\n","category":"function"},{"location":"library_internal.html#EGRIP.check_voltage_setpoints-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_voltage_setpoints","text":"throws warnings if generator and dc line voltage setpoints are not consistent with the bus voltage setpoint\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.make_mixed_units-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_mixed_units","text":"Transforms network data into mixed-units (inverse of per-unit)\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.make_per_unit-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_per_unit","text":"Transforms network data into per-unit\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.matpower_to_powermodels-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.matpower_to_powermodels","text":"Converts a Matpower dict into a PowerModels dict\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_bus_name_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_bus_name_data","text":"merges bus name data into buses, if names exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_generator_cost_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generator_cost_data","text":"merges generator cost functions into generator data, if costs exist\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.merge_generic_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generic_data","text":"merges Matpower tables based on the table extension syntax\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp2pm_branch-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_branch","text":"sets all branch transformer taps to 1.0, to simplify branch models\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp2pm_dcline-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_dcline","text":"adds pmin and pmax values at to and from buses\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.mp_cost_data-Tuple{Any}","page":"Internal Library","title":"EGRIP.mp_cost_data","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_cells-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_cells","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_data-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_data","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matlab_matrix-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_matrix","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_file-Tuple{IO}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_file-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_matpower_string-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_string","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.parse_mfile-Tuple{Union{IO, String}}","page":"Internal Library","title":"EGRIP.parse_mfile","text":"Parses the matpower data from either a filename or an IO object\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.row_to_dict-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.row_to_dict","text":"takes a row from a matrix and assigns the values names\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.simplify_cost_terms-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.simplify_cost_terms","text":"trims zeros from higher order cost terms\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.split_line-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.split_line","text":"\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.split_loads_shunts-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.split_loads_shunts","text":"splitloadsshunts(data) Seperates Loads and Shunts in data under separate \"load\" and \"shunt\" keys in the PowerModels data format. Includes references to originating bus via \"loadbus\" and \"shuntbus\" keys, respectively.\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.type_array-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Internal Library","title":"EGRIP.type_array","text":"Attempts to determine the type of an array of strings extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"library_internal.html#EGRIP.type_value-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.type_value","text":"Attempts to determine the type of a string extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"index.html#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"EGRIP.jl is a Julia/JuMP package for power system restoration.","category":"page"}]
}
