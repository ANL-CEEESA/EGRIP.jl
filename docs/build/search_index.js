var documenterSearchIndex = {"docs":
[{"location":"ch4_sec2_benchmark.html#Benchmark-Testing-1","page":"Benchmark Testing","title":"Benchmark Testing","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#Code-Loading-1","page":"Code Loading","title":"Code Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The current confusion is on how Julia load packages and modules that are not registered through Pkg.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Working-Directory-1","page":"Code Loading","title":"Working Directory","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"The working directory, which can be obtained by pwd(), has to be the one containing our packages for things to be loaded correctly.\nWe can add the command cd(@__DIR__) at the beginning of our code to navigate the directory to where our code is running.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Package-Loading-1","page":"Code Loading","title":"Package Loading","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Assmue we would like to use our developed but unregistered package EGRIP.jl at a Julia file named testrun.jl. There are two ways to load EGRIP.jl.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Include-the-package-and-corresponding-modules-1","page":"Code Loading","title":"Include the package and corresponding modules","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can include the main jl file of the package at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory containing `testrun.jl`\ninclude(\"path to the source code from current working directory/src/EGRIP.jl\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through relative path import of the main module since it cannot be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using .EGRIP # It tells Julia to find the module around the current working directory instead of Julia Environment","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Due to the similar reason, other modules in the package cannot be identified by Julia Environment. When module_a in file_module_a.jl needs to use a function fun_b from module_b in file_module_b.jl, we need to do the following at the beginning of file_module_a.jl (assmue file_module_a.jl and file_module_b.jl are in the same directory):","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"include(\"file_module_b.jl\")\nusing .module_b","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, if fun_b has been exported, we can directly access it. Otherwise. we need to use module_b.fun_b. This is not very convenient.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Add-source-code-directory-into-Julia-Environment-1","page":"Code Loading","title":"Add source code directory into Julia Environment","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"We can make source directory accessible through Julia's LOAD_PATH. We can add the following line at the top of testrun.jl:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"cd(@__DIR__) # navigate to correct working directory `testrun.jl`\npush!(LOAD_PATH,\"path to the source code from current working directory/src/\")","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Then, we can use the package through absolute path import of the main module since it can be identified by Julia Environment:","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"using EGRIP # It tells Julia to find the module in Julia Environment LOAD_PATH","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"In addition, all other modules can be used in the same way.","category":"page"},{"location":"ch3_sec2_dev_code_loading.html#Discussion-on-include-1","page":"Code Loading","title":"Discussion on include","text":"","category":"section"},{"location":"ch3_sec2_dev_code_loading.html#","page":"Code Loading","title":"Code Loading","text":"Julia’s include is a function, not a simple input redirector (as in C, Fortran, or Matlab).\nEvaluate the contents of a source file in the current context. “The current context” means the global scope of the current module when the evaluation takes place.\nThis function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\nInclude works in the dynamically-current module, not the lexically-current one.\nIt is really a load-time function, not a run-time one.","category":"page"},{"location":"ch1_sec1_install.html#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"For now since EGRIP.jl has not been registered, we need to load the package locally by putting the following code at the beginning of your test script:","category":"page"},{"location":"ch1_sec1_install.html#","page":"Installation","title":"Installation","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")","category":"page"},{"location":"ch2_sec2_library_internal.html#Internal-Library-1","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#Formulation-Function-1","page":"Internal Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"bs_initial_step.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP.solve_restoration-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_branch-NTuple{9,Any}","page":"Internal Library","title":"EGRIP.form_branch","text":"branch (power flow) constraints\n\nlinearized power flow\n\nbeginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_bs_logic-NTuple{8,Any}","page":"Internal Library","title":"EGRIP.form_bs_logic","text":"generator cranking constraint\n\nOnce a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time\n\"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator\nset non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power\nMathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability\nThere will be the following scenarios\n(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g\nAll scenarios can be formulated as follows:\n\nbeginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gTcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_gen_logic-NTuple{8,Any}","page":"Internal Library","title":"EGRIP.form_gen_logic","text":"generator status and output constraint\n\ngenerator ramping rate constraint\n\nbeginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*\n\nblack-start unit is determined by the cranking power\n\nbeginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*\n\non-line generators cannot be shut down\n\nbeginalign*\ny_gt = y_gt+1\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_load_logic-NTuple{6,Any}","page":"Internal Library","title":"EGRIP.form_load_logic","text":"load pickup constraint\n\nrestored load cannot exceed its maximum values\n\nbeginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*\n\nrestored load cannot be shed\n\nbeginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.form_nodal-NTuple{17,Any}","page":"Internal Library","title":"EGRIP.form_nodal","text":"form the nodal constraints:\n\nvoltage constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized\n\nbeginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\nendalign*\n\nangle difference constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized\n\n beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-ajt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*\n\ngenerator and bus energizing logics\non-line generator cannot be shut down\nbus should be energized before the connected genertor being on\n\nbeginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#I/O-Function-1","page":"Internal Library","title":"I/O Function","text":"","category":"section"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"use @autodocs block to splice the docstrings","category":"page"},{"location":"ch2_sec2_library_internal.html#","page":"Internal Library","title":"Internal Library","text":"Modules = [EGRIP]\nPages   = [\"parser.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"ch2_sec2_library_internal.html#EGRIP._check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP._check_conductors","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._check_cost_function-Tuple{Any,Any,Any}","page":"Internal Library","title":"EGRIP._check_cost_function","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._make_mixed_units-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_mixed_units","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._make_per_unit-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._make_per_unit","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._rescale_cost_model-Tuple{Dict{String,Any},Real}","page":"Internal Library","title":"EGRIP._rescale_cost_model","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP._simplify_pwl_cost","page":"Internal Library","title":"EGRIP._simplify_pwl_cost","text":"checks the slope of each segment in a pwl function, simplifies the function if the slope changes is below a tolerance\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec2_library_internal.html#EGRIP.add_dcline_costs-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.add_dcline_costs","text":"adds dcline costs, if gen costs exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.add_line_delimiter-Tuple{AbstractString,Any,Any}","page":"Internal Library","title":"EGRIP.add_line_delimiter","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.apply_func-Tuple{Dict{String,Any},String,Any}","page":"Internal Library","title":"EGRIP.apply_func","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.arrays_to_dicts!-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.arrays_to_dicts!","text":"turns top level arrays into dicts\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_branch_directions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_directions","text":"checks that all parallel branches have the same orientation\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_branch_loops-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_branch_loops","text":"checks that all branches connect two distinct buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_bus_types-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_bus_types","text":"checks bus types are consistent with generator connections, if not, fixes them\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_conductors-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_conductors","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_connectivity-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_connectivity","text":"checks that all buses are unique and other components link to valid buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_cost_functions-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_cost_functions","text":"throws warnings if cost functions are malformed\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_current_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_current_limits","text":"checks that each branch has a reasonable current rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_dcline_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_dcline_limits","text":"checks that parameters for dc lines are reasonable\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_keys-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_keys","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_network_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_network_data","text":"Runs various data quality checks on a PowerModels data dictionary. Applies modifications in some cases.  Reports modified component ids.\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_storage_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_storage_parameters","text":"checks that each storage unit has a reasonable parameters\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_thermal_limits-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_thermal_limits","text":"checks that each branch has a reasonable thermal rating-a, if not computes one\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_transformer_parameters-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_transformer_parameters","text":"checks that each branch has a reasonable transformer parameters this is important because setting tap == 0.0 leads to NaN computations, which are hard to debug\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_type-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.check_type","text":"Checks if the given value is of a given type, if not tries to make it that type\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_voltage_angle_differences","page":"Internal Library","title":"EGRIP.check_voltage_angle_differences","text":"checks that voltage angle differences are within 90 deg., if not tightens\n\n\n\n\n\n","category":"function"},{"location":"ch2_sec2_library_internal.html#EGRIP.check_voltage_setpoints-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.check_voltage_setpoints","text":"throws warnings if generator and dc line voltage setpoints are not consistent with the bus voltage setpoint\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.make_mixed_units-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_mixed_units","text":"Transforms network data into mixed-units (inverse of per-unit)\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.make_per_unit-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.make_per_unit","text":"Transforms network data into per-unit\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.matpower_to_powermodels-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.matpower_to_powermodels","text":"Converts a Matpower dict into a PowerModels dict\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_bus_name_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_bus_name_data","text":"merges bus name data into buses, if names exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_generator_cost_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generator_cost_data","text":"merges generator cost functions into generator data, if costs exist\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.merge_generic_data-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.merge_generic_data","text":"merges Matpower tables based on the table extension syntax\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp2pm_branch-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_branch","text":"sets all branch transformer taps to 1.0, to simplify branch models\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp2pm_dcline-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.mp2pm_dcline","text":"adds pmin and pmax values at to and from buses\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.mp_cost_data-Tuple{Any}","page":"Internal Library","title":"EGRIP.mp_cost_data","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_cells-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_cells","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_data-NTuple{4,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_data","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matlab_matrix-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.parse_matlab_matrix","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_file-Tuple{IO}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_file-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_file","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_matpower_string-Tuple{String}","page":"Internal Library","title":"EGRIP.parse_matpower_string","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.parse_mfile-Tuple{Union{IO, String}}","page":"Internal Library","title":"EGRIP.parse_mfile","text":"Parses the matpower data from either a filename or an IO object\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.row_to_dict-Tuple{Any,Any}","page":"Internal Library","title":"EGRIP.row_to_dict","text":"takes a row from a matrix and assigns the values names\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.simplify_cost_terms-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.simplify_cost_terms","text":"trims zeros from higher order cost terms\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.split_line-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.split_line","text":"\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.split_loads_shunts-Tuple{Dict{String,Any}}","page":"Internal Library","title":"EGRIP.split_loads_shunts","text":"splitloadsshunts(data) Seperates Loads and Shunts in data under separate \"load\" and \"shunt\" keys in the PowerModels data format. Includes references to originating bus via \"loadbus\" and \"shuntbus\" keys, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.type_array-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:AbstractString","page":"Internal Library","title":"EGRIP.type_array","text":"Attempts to determine the type of an array of strings extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"ch2_sec2_library_internal.html#EGRIP.type_value-Tuple{AbstractString}","page":"Internal Library","title":"EGRIP.type_value","text":"Attempts to determine the type of a string extracted from a matlab file\n\n\n\n\n\n","category":"method"},{"location":"ch3_sec3_dev_package_org.html#Package-Organization-1","page":"Package Organization","title":"Package Organization","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#Option-1-1","page":"Package Organization","title":"Option 1","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We could build one main module called EGRIP and several submodules.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In this way, we will declare certain submodule to access its function in another module once the source code is loaded into LOAD_PATH.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"For example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"Then, in a testing script, we can use the package by","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using EGRIP\nfun_bs()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"In addition, we can use the module independently from EGRIP","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"using PowerFlow\nfun_pf()","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"A different but not good way to do include file.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"This is suggested to do the include in the main module. And once it is loaded to LOAD_PATH, every included script is accessible.","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"load_restoration.jl\")\nusing PowerFlow\nusing LoadRestoration\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module PowerFlow\nexport func_pf\nfunction func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module LoadRestoration\ninclude(\"power_flow.jl\")\nusing PowerFlow\nexport func_lr\nfunction func_lr()\n  func_pf()\nend\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#Option-2-1","page":"Package Organization","title":"Option 2","text":"","category":"section"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"We just build one main module EGRIP. The rest functionalities are implemented by functions in different scripts. Then, we just need to include the scripts in the main module. Once the main module is loaded into LOAD_PATH, we can these functions freely between different scripts without further declaration. Some Julia packages like PowerModels.jl are organized in this way. Take an example:","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"EGRIP/src/","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-EGRIP.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"module EGRIP\ninclude(\"power_flow.jl\")\ninclude(\"load_restoration.jl\")\nfunction fun_bs()\n  fun_pf()\n  fun_lr()\nend\nexport fun_bs\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-power_flow.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_pf()\nend","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"-load_restoration.jl","category":"page"},{"location":"ch3_sec3_dev_package_org.html#","page":"Package Organization","title":"Package Organization","text":"function func_lr()\n  func_pf()\nend","category":"page"},{"location":"ch2_sec1_library_public.html#Public-Library-1","page":"Public Library","title":"Public Library","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#Formulation-Function-1","page":"Public Library","title":"Formulation Function","text":"","category":"section"},{"location":"ch2_sec1_library_public.html#","page":"Public Library","title":"Public Library","text":"use @docs block to splice the docstrings","category":"page"},{"location":"ch2_sec1_library_public.html#","page":"Public Library","title":"Public Library","text":"solve_restoration","category":"page"},{"location":"ch2_sec1_library_public.html#EGRIP.solve_restoration","page":"Public Library","title":"EGRIP.solve_restoration","text":"Solve restoration problem including the following constraints:\n\nlinearized AC power flow constraint\nsteady-state voltage variation constraint\ngenerator cranking constraint\ngenerator status and output constraint\nload pick-up constraint\n\n\n\n\n\n","category":"function"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Optimization-and-Verification-Workflow-1","page":"Restoration Workflow","title":"Restoration Plan Optimization and Verification Workflow","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Integrated restoration optimization model produces an initial parallel recovery plan\nCranking path module finds transmission path to energize to crank a generator\nTransient stability and static security constraints are validated by simulation\nThree options to fix a restoration plan\nAdd compensation devices\nSwitch to another cranking path\nRe-optimize startup sequences\nIf a restoration plan cannot be repaired (or sacrifice too much solution quality), remove current plan from solution space and resolve the integrated restoration optimization model","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"(Image: Restoration workflow)","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Optimization-1","page":"Restoration Workflow","title":"Restoration Plan Optimization","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#Interactive-Usage-1","page":"Restoration Workflow","title":"Interactive Usage","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"We can load and use the package using:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"First, we need to tell the package where our problem data is. Assume the data is at the same directory of the executing script, then the data can be loaded as:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_network = \"case39.m\"\ndir_case_blackstart = \"BS_generator.csv\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Second, we need to tell the package where our results are going to be stored. Let's save the results in a child folder results:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dir_case_result = \"results/\"","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Then, we define the restoration duration and time steps:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"t_final = 300\nt_step = 100","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"At last, we set the gap for the solver:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"gap = 0.15","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once everything is ready, we can call solve_restoration function to solve the problem:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"solve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Part of the results will be printed once the algorithm terminates.","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Line energization:\nstage 1.0:\nstage 2.0:\nstage 3.0: (8,9) (25,37) (16,17) (20,34) (22,23) (19,20) (22,35) (6,11) (9,39) (13,14) (5,8) (19,33) (26,27) (14,15) (12,13) (10,13) (15,16) (16,24) (12,11) (29,38) (16,19) (23,36) (6,31) (26,29) (23,24) (5,6) (4,14) (17,27) (25,26)\n\nGenerator energization:\nstage 1.0: 39\nstage 2.0:\nstage 3.0: 36 33 38 31 37 34 35\n\nBus energization:\nstage 1.0: 12 1 11 39 19 20 13\nstage 2.0: 18 16 5\nstage 3.0: 2 21 7 26 25 35 34 29 10 9 17 8 22 6 24 4 37 28 38 23 31 14 27 36 15 33","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Detailed results will be stored in results folder under the directory containing the case file.","category":"page"},{"location":"ch1_sec4_workflow.html#Command-Line-Usage-1","page":"Restoration Workflow","title":"Command Line Usage","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Alternatively, we can build a command-line tool. First, we create a script file named solve_bs.jl and write the following Julia code in the script:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"cd(@__DIR__)\npush!(LOAD_PATH,\"../src/\")\nusing EGRIP\ndir_case_network = ARGS[1]\ndir_case_blackstart = ARGS[2]\ndir_case_result = ARGS[3]\nt_final = parse(Int64, ARGS[4])\nt_step = parse(Int64, ARGS[5])\ngap = parse(Float64, ARGS[6])\nsolve_restoration(dir_case_network, dir_case_blackstart, dir_case_result, t_final, t_step, gap)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Open Terminal and navigate to the directory containing solve_bs.jl.","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"$ cd /path to solve_bs/","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Execute the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"$ julia solve_bs.jl 'case39.m' 'BS_generator.csv' 'results/' 300 100 0.15","category":"page"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-Verification-1","page":"Restoration Workflow","title":"Restoration Plan Verification","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#Restoration-Plan-File-Generation-1","page":"Restoration Workflow","title":"Restoration Plan File Generation","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"This process consists of two steps. The first step is to generate restoration plan file (an event list) using the function generateRestorationPlanFromOpt. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"optResPath: The path containing the optimized restoration plan result\noutFileName: the name of the restoration plan file to be generated\ndataFile: The name of the associated system data file (PSAT format, .m)\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function will output exitflag, which 1 means success and fail otherwise. The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"generateRestorationPlanFromOpt('D:\\Box Sync\\Blackstart_data\\Blackstart_data\\','restoration_plan_test_039.m','d_datane_39_mod_PQ_3')","category":"page"},{"location":"ch1_sec4_workflow.html#Simulation-1","page":"Restoration Workflow","title":"Simulation","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the event list is generated, we can run the simulation using the function runDynamicSimulation. We need the following inputs:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"dataFile: The name of the associated system data file (PSAT format, .m)\nrestSettingFile: the name of the restoration plan file\ndataPath (optional): the path of the datafile\nOptions (optional): extra options","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"There will be two outpus:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"exitflag=1: run the whole simulation, otherwise: DSA did not finish all the simulation\nmsg: detailed message","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The function can be called using the following command:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"[flag,msg]=runDynamicSimulation('d_datane_39_mod_PQ_3','restoration_plan_test_039')","category":"page"},{"location":"ch1_sec4_workflow.html#Plots-1","page":"Restoration Workflow","title":"Plots","text":"","category":"section"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Once the simulation is completed, we could load the simulation data:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"Load the *_simp.mat result file (located in ./restoration/)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"and plot the results:","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"plotCurves(1,t,stateCurve,SysDataBase,’variableName’)","category":"page"},{"location":"ch1_sec4_workflow.html#","page":"Restoration Workflow","title":"Restoration Workflow","text":"The results of the IEEE 39-bus system are shown below. (Image: Enhanced Extended-Term Simulation) (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch4_sec1_literature.html#Literature-Review-1","page":"Literature Review","title":"Literature Review","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#Mathematical-Model-1","page":"Problem Formulations","title":"Mathematical Model","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#Sets,-Parameters-and-Variables-1","page":"Problem Formulations","title":"Sets, Parameters and Variables","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n\nmboxIndices and Sets   \n ijin N mbox - buses \n bin B mbox - branches \n gin G mbox - generators \n lin L mbox - loads \n\nmboxParameters   \n Pcr_g quadforall g in G mbox - generator cranking power power needed for the unit to be normally functional\n Tcr_g quadforall g in G mbox - generator cranking time time needed for the unit to be normally functional\n Krp_g quadforall g in G mbox - generator ramping rate \n\nmboxBinary Variables   \n x_ijt mbox - status of line ij at time t\n y_gt mbox - status of generator g at time t\n u_it mbox - status of bus i at time t\n\nmboxContinuous Variables   \n v_it mbox - voltage of bus i at time t\n a_it mbox - relative angle of bus i at time t\n vl_ijt mbox - supplementary variables for voltage of bus i (connected to bus j) at time t\n vb_it mbox - supplementary variables for voltage of bus i at time t\n al_ijt mbox - supplementary variables for relative angle of bus i (connected to bus j) at time t\n pl_lt mbox - active power of load l at time t\n ql_lt mbox - reactive power of load l at time t\n pg_lt mbox - active power of generator g at time t\n qg_lt mbox - reactive power of generator g at time t\n p_bijt mbox - active power flow of branch b (bus i and j) at time t\n q_bijt mbox - reactive power flow of branch b (bus i and j) at time t\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Branch-Constraints-1","page":"Problem Formulations","title":"Branch Constraints","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of branch constraints are implemented in function form_branch.","category":"page"},{"location":"ch1_sec2_formulations.html#Power-Flow-Equations-1","page":"Problem Formulations","title":"Power Flow Equations","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The typical π-circuit line model with an ideal transformer is used to model the standard \"AC\" power flow: (Image: Line model)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The Y-bus can be formulated as follows: (Image: Y bus)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Three representations of AC power flow can be found below: (Image: AC power flow)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Molzahn, Daniel K., and Ian A. Hiskens. \"A survey of relaxations and approximations of the power flow equations.\" Foundations and Trends® in Electric Energy Systems 4, no. 1-2 (2019): 1-221.)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The standard \"DC\" approximation to AC power flow linearizes these equations by using the approximations v_i=v_j=1, sinα_ij=α_ij, cosα_ij=1, and b_lg_l=0 yielding:","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\np_ij=B_ijα_ij\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Expanding the line flows about v_i=v_j=1, α_ij=0 and making small-angle approximations sinα_ij=α_ij and cosα_ij=1 yielding linearized AC power flow","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n p_ijt=G_ii(2v_it-1) + G_ij(v_it + v_jt-1) + B_ijsinα_ij\n q_ijt=-B_ii(2v_it-1) - B_ij(v_it + v_jt-1) + G_ijcosα_ij\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"where voltage and reactive power are retained.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Trodden, Paul A., Waqquas Ahmed Bukhsh, Andreas Grothey, and Ken IM McKinnon. \"Optimization-based islanding of power networks using piecewise linear AC power flow.\" IEEE Transactions on Power Systems 29, no. 3 (2013): 1212-1220.)","category":"page"},{"location":"ch1_sec2_formulations.html#Linearized-AC-Power-Flow-Constraints-Under-Restoration-1","page":"Problem Formulations","title":"Linearized AC Power Flow Constraints Under Restoration","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\np_bijt=G_ii(2vl_ijt-x_ijt) + G_ij(vl_ijt + vl_jit-x_ijt) + B_ij(al_ijt-al_ijt)\nq_bijt=-B_ii(2vl_ijt-x_ijt) - B_ij(vl_ijt + vl_jit-x_ijt) + G_ij(al_ijt-al_ijt)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Nodal-Constraints-1","page":"Problem Formulations","title":"Nodal Constraints","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of nodal constraints are implemented in function form_nodal.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Voltage Constraint\nvoltage deviation should be limited\nvoltage constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n     v^min_i leq v_it leq v^max_i\n     v^min_ix_ijt leq vl_ijt leq v^max_ix_ijt\n     v^min_jx_ijt leq vl_jit leq v^max_jx_ijt\n     v_it - v^max_i(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\n     v_jt - v^max_j(1-x_ijt) leq vl_ijt leq v_it - v^min_i(1-x_ijt)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Angle Difference Constraint\nangle difference should be limited\nangle difference constraints are only activated if the associated line is energized","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":" beginalign*\n      a^min_ij leq a_it-a_jt leq a^max_ij\n      a^min_ijx_ijt leq al_ijt-al_jit leq a^max_ijx_ijt\n      a_it-ajt-a^max_ij(1-x_ijt) leq al_ijt-al_jit leq a_it-a_jt-a^min_ij(1-x_ijt)\n endalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Generator and Bus Energizing Logics\non-line generator cannot be shut down\nbus should be energized before the connected genertor being on","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n  x_ijt geq x_ijt-1\n  u_it geq x_ijt\n  u_jt geq x_ijt\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Generator-Cranking-Constraints-1","page":"Problem Formulations","title":"Generator Cranking Constraints","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations of generator cranking constraints are implemented in function form_bs_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The capacity curve for non-black start generator is simplifed and modeled as a piecewise linear function of time shown below.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Image: Capacity curve)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(Ref: Qiu, Feng, and Peijie Li. \"An integrated approach for power system restoration planning.\" Proceedings of the IEEE 105, no. 7 (2017): 1234-1252.)","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Once a non-black start generator is on, that is, y_gt=1, then it needs to absorb the cranking power for its corresponding cranking time. \"After\" the time step that this unit satisfies its cranking constraint, its power goes to zero; and from the next time step, it becomes a dispatchable generator","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"set non-black start unit generation limits based on \"generator cranking constraint\"\ncranking constraint states if generator g has absorb the cranking power for its corresponding cranking time, it can produce power","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Mathematically if there exist enough 1 for y_gt=1, then enable this generator's generating capability. There will be the following scenarios","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"(1) generator is off, then y_gt-y_gt-Tcr_g = 0, then pg_gt = 0\n(2) generator is on but cranking time not satisfied, then y_gt - y_gt-Tcr_g = 1, then pg_gt = -Pcr_g\n(3) generator is on and just satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=0, then pg_gt = 0\n(4) generator is on and bigger than satisfies the cranking time, then y_gt - y_gt-Tcr_g = 0, y_gt-Tcr_g-1=1, then 0 = pg_gt = pg^max_g","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"All scenarios can be formulated as follows:","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n pg^min_g leq pg_gt leq pg^max_g\n text if t  Tcr_g+1\n quadquad -Pcr_g(y_gt-y_gTcr_g) leq pg_gt leq pg^max_gy_gt-Tcr_g-1-Pcr_g(y_gt - y_gt-Tcr_g) \n text elseif t leq Tcr_g\n quadquad pg_gt = -Pcr_gy_gt\n textelse \n quadquad pg_gt = -Pcr_g(y_gt - y_g1)\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Generator-Status-and-Output-Constraint-1","page":"Problem Formulations","title":"Generator Status and Output Constraint","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations are implemented in function form_gen_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Generator ramping rate constraint","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n-Krp_g leq pg_gt-pg_gt+1 leq Krp_g\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"Black-start unit is determined by the cranking power","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\ny_gt=1 text  if   Pcr_g=0\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"On-line generators cannot be shut down","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\ny_gt = y_gt+1\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#Load-Pickup-Constraint-1","page":"Problem Formulations","title":"Load Pickup Constraint","text":"","category":"section"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"The formulations are implemented in function form_load_logic.","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"restored load cannot exceed its maximum values","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n 0 leq pl_lt leq pl^maxu_lt\n 0 leq ql_lt leq ql^maxu_lt\nendalign*","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"restored load cannot be shed","category":"page"},{"location":"ch1_sec2_formulations.html#","page":"Problem Formulations","title":"Problem Formulations","text":"beginalign*\n pl_lt-1 leq pl_lt\n ql_lt-1 leq ql_lt\nendalign*","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Advanced-Algorithms-1","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#Multi-Resolution-Approach-1","page":"Advanced Algorithms","title":"Multi-Resolution Approach","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We developed a multi-resolution restoration algorithm to accelerate the overall solution time and prepare the software package for large-scale systems. The approach is based on the fact that better solutions can be found with smaller time steps, that is, higher resolution, which results in more complex optimization model. In addition, it is often difficult for the solver to obtain a feasible solution when the time step is small. Therefore, the essence of the algorithm is to hierarchically increase the resolution (that is, decrease the time steps) and guide the search of higher-resolution problem using solutions from lower-resolution solutions. Specifically, generator decision variables at certain time interval will be fixed to either zero or one depending on the result from the previous step. The algorithm is illustrated in Figure 1, where Figure 1 (a) shows the step of the approach and Figure 1 (b) illustrate the fixing rules. (Image: Multi-resolution method)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We verify the method on the black start problem for the IEEE 39-bus system. The computation results are shown in Table 1 with total time equal to 300 minutes. In Scenario 2, the solver cannot reach to convergence after 71 hours. On the other hand, the proposed method can save eight times of the computation time with slightly compromised optimality. This preliminary computation experiments verify the effectiveness of our proposed approach.","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"Scenario Index Gap Resolution (min) Solving Time (sec) With Fixed Constraint All generator dispatchable (min)\n1 1% 50 728 No 251\n2 1% 20 255854 (71h) without convergence No \\\n3 10% 20 8709 No 201\n4 5% 20 327 Generator sequence fixed based on S1 221","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#Enhanced-Extended-Term-Event-Driven-Simulation-1","page":"Advanced Algorithms","title":"Enhanced Extended-Term Event-Driven Simulation","text":"","category":"section"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We enhanced the extended-term simulation approach based on semi-analytical simulation (SAS) for restoration studies. And we implemented hybrid simulation switching between the full-dynamic simulation and quasi-steady-state (QSS) simulation. The switch from full-dynamic simulation to QSS simulation is realized directly from SAS coefficients, which is much more efficient than the traditional method that needs extra period of simulation. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch1_sec3_advanced_algorithm.html#","page":"Advanced Algorithms","title":"Advanced Algorithms","text":"We further use SAS to simulate a restoration process of IEEE 39-bus system. The whole process lasts 12,065s and includes 396 events, including bus energization, line energization, line switching, generator cut-in, generator ramping, load cut-in, load ramping events. The QSS simulation covers about 39% of the whole process, and the time saving compared with full-dynamic simulation is about 36%. This verifies that QSS simulation is much faster than the full-dynamic simulation, and the hybrid simulation can significantly enhance efficiency without losing accuracy. (Image: Enhanced Extended-Term Simulation)","category":"page"},{"location":"ch3_sec1_development_overview.html#Development-Overview-1","page":"Development Overview","title":"Development Overview","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Directory-Tree-1","page":"Development Overview","title":"Directory Tree","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Dependency-1","page":"Development Overview","title":"Dependency","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#Documentation-Notes-1","page":"Development Overview","title":"Documentation Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"We use Documenter.jl.","category":"page"},{"location":"ch3_sec1_development_overview.html#Other-Detailed-Notes-1","page":"Development Overview","title":"Other Detailed Notes","text":"","category":"section"},{"location":"ch3_sec1_development_overview.html#","page":"Development Overview","title":"Development Overview","text":"Code Loading\nPackage Organization","category":"page"},{"location":"index.html#EGRIP.jl-Documentation-1","page":"Home","title":"EGRIP.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = EGRIP","category":"page"},{"location":"index.html#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Welcome to the documentation for EGRIP.jl!","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"EGRIP.jl (Electricity Grid Resilience Improvement Program) is a Julia/MATALB package for power system restoration planning and verification. The objective of this toolkit is to:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Improve the preparedness of power systems for extreme weather conditions\nEnhance the capability of quick recovery from damages (such as partial or complete blackout)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The holistic framework shown below consists of three main modules: nowcasting weather forecasting, simulation and restoration.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simulation module provides predictive outages and damages, and dynamic security assessment for restoration plan to guarantee practicality\nRestoration module provides Multi-time scale (resource allocation and operation) multi-level (bulk power system and distribution level) restoration optimization","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Holistic structure)","category":"page"},{"location":"index.html#Optimization-Core-1","page":"Home","title":"Optimization Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The optimization core is designed in a modularize and hierarchical manner to facilitate future algorithm development, multi-purpose usage as well as reduce the coding overhead. It consists of three levels, that is, fundamental function level, ordinary problem level and advanced solution level.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The fundamental function level is to provide basic optimization formulations. Currently it consists of generator dispatch model, generator cranking model, controllable load dispatch model, linearized AC power flow model and AC power flow model as well as data I/O.\nThe ordinary problem level formulates different problems using appropriate functions from both fundamental and its own levels. Currently there are three ordinary problems, that is, load restoration problem, system black-start problem and AC power flow feasibility checking problem. The load restoration problem is to maximize served load under a energized topology. The system black-start problem is to simultaneously energize the system and restore load service through black-start units.\nThe advanced solution level is to either speed up the computation or accommodate new capabilities using both state-of-the-art optimization algorithm and power system domain knowledge. Currently it consists of the multi-resolution restoration algorithm and meta heuristic enhancement. The multi-resolution restoration algorithm is to accelerate the overall solution time by guiding the search of higher-resolution problem using solutions from lower-resolution solutions. The meta heuristic enhancement uses power system domain knowledge and to add additional physical constraints and empirical rules to speed up the computation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Simulation-Core-1","page":"Home","title":"Simulation Core","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The simulation core is used for the resilience assessment of system under possible extreme events and in the restoration process. The simulation core utilizes the simulation tool based on semi-analytical solutions (SAS). The SAS has enhanced numerical robustness and computational efficiency, which enables the analysis of very complex dynamic processes in large-scale power systems. The SAS-based simulation tool has the following major features:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Flexible customization of event sequences. Users can conveniently define the event sequences through an event list file. The simulation tool supports various types of events, such as adding/tripping components, adding/clearing faults, ramping of load/ generation. The event scheduler dispatches the simulation workflow to simulate the event sequence.\nRich model library. The simulation tool supports steady-state analysis and dynamic simulation. The model library includes dynamic models of synchronous generators, controllers (AVR and turbine governor), static load (e.g. ZIP) and induction motor load, and AGC model. And the model library is still expanding. The simulation tool admits widely supported PSAT data format.\nEnhanced robustness. The SAS as a high-order advanced computational approach with analytical form, has guaranteed numerical convergence to existing solution. Therefore, the SAS users are worry-free of non-convergence issues, and the simulation tool has good capability of performing very complex power system resilience analysis tasks.\nEnhanced efficiency with steady-state & dynamic hybrid simulation. The simulator automatically switches between full-dynamic simulation (where fast transients are significant) and quasi-steady-state (QSS) simulation (where the transients decay and approximately enters steady-state). The hybrid simulation scheme significantly saves computation time compared with the full-dynamic simulation, typically by 30%-70% depending on studied cases.\nFriendly output and visualization functions. The SAS-based simulation tool has a log system that enables printing and recording different levels of events in simulation. After simulation, users can conveniently plot the trajectories of various system states through a specially designed plotting function.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Toolkit structure)","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Installation\nMathematical Model\nAdvanced Algorithms\nRestoration Planning and Verification Workflow","category":"page"},{"location":"index.html#Library-1","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Public Library\nInternal Library","category":"page"},{"location":"index.html#Developer-1","page":"Home","title":"Developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Development Overview\nCode Loading\nPackage Organization","category":"page"},{"location":"index.html#Research-1","page":"Home","title":"Research","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Literature Review\nBenchmark Testing","category":"page"}]
}
